"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sanity-diff-patch";
exports.ids = ["vendor-chunks/sanity-diff-patch"];
exports.modules = {

/***/ "(ssr)/./node_modules/sanity-diff-patch/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/sanity-diff-patch/dist/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar diffMatchPatch = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.cjs\");\nfunction pathToString(path) {\n  return path.reduce((target, segment, i) => {\n    if (Array.isArray(segment)) {\n      return \"\".concat(target, \"[\").concat(segment.join(\":\"), \"]\");\n    }\n    if (isKeyedObject(segment)) {\n      return \"\".concat(target, \"[_key==\\\"\").concat(segment._key, \"\\\"]\");\n    }\n    if (typeof segment === \"number\") {\n      return \"\".concat(target, \"[\").concat(segment, \"]\");\n    } else if (typeof segment === \"string\" && /^\\d+$/.test(segment)) {\n      return \"\".concat(target, \"[\\\"\").concat(segment, \"\\\"]\");\n    }\n    if (typeof segment === \"string\") {\n      const separator = i === 0 ? \"\" : \".\";\n      return \"\".concat(target).concat(separator).concat(segment);\n    }\n    throw new Error(\"Unsupported path segment \\\"\".concat(segment, \"\\\"\"));\n  }, \"\");\n}\nfunction isKeyedObject(obj) {\n  return typeof obj === \"object\" && typeof obj._key === \"string\";\n}\nclass DiffError extends Error {\n  constructor(message, path, value) {\n    const serializedPath = pathToString(path);\n    super(\"\".concat(message, \" (at '\").concat(serializedPath, \"')\"));\n    this.path = path;\n    this.serializedPath = serializedPath;\n    this.value = value;\n  }\n}\nconst idPattern = /^[a-z0-9][a-z0-9_.-]+$/i;\nconst propPattern = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nconst propStartPattern = /^[a-z_]/i;\nfunction validateProperty(property, value, path) {\n  if (!propStartPattern.test(property)) {\n    throw new DiffError(\"Keys must start with a letter (a-z)\", path.concat(property), value);\n  }\n  if (!propPattern.test(property)) {\n    throw new DiffError(\"Keys can only contain letters, numbers and underscores\", path.concat(property), value);\n  }\n  if (property === \"_key\" || property === \"_ref\" || property === \"_type\") {\n    if (typeof value !== \"string\") {\n      throw new DiffError(\"Keys must be strings\", path.concat(property), value);\n    }\n    if (!idPattern.test(value)) {\n      throw new DiffError(\"Invalid key - use less exotic characters\", path.concat(property), value);\n    }\n  }\n  return property;\n}\nconst ignoredKeys = [\"_id\", \"_type\", \"_createdAt\", \"_updatedAt\", \"_rev\"];\nconst defaultOptions = {\n  hideWarnings: false,\n  diffMatchPatch: {\n    enabled: true,\n    // Only use diff-match-patch if target string is longer than this threshold\n    lengthThresholdAbsolute: 30,\n    // Only use generated diff-match-patch if the patch length is less than or equal to\n    // (targetString * relative). Example: A 100 character target with a relative factor\n    // of 1.2 will allow a 120 character diff-match-patch. If larger than this number,\n    // it will fall back to a regular `set` patch.\n    lengthThresholdRelative: 1.2\n  }\n};\nfunction mergeOptions(options) {\n  return {\n    ...defaultOptions,\n    ...options,\n    diffMatchPatch: {\n      ...defaultOptions.diffMatchPatch,\n      ...(options.diffMatchPatch || {})\n    }\n  };\n}\nfunction diffPatch(itemA, itemB, opts) {\n  const options = mergeOptions(opts || {});\n  const id = options.id || itemA._id === itemB._id && itemA._id;\n  const revisionLocked = options.ifRevisionID;\n  const ifRevisionID = typeof revisionLocked === \"boolean\" ? itemA._rev : revisionLocked;\n  const basePath = options.basePath || [];\n  if (!id) {\n    throw new Error(\"_id on itemA and itemB not present or differs, specify document id the mutations should be applied to\");\n  }\n  if (revisionLocked === true && !ifRevisionID) {\n    throw new Error(\"`ifRevisionID` is set to `true`, but no `_rev` was passed in item A. Either explicitly set `ifRevisionID` to a revision, or pass `_rev` as part of item A.\");\n  }\n  if (basePath.length === 0 && itemA._type !== itemB._type) {\n    throw new Error(\"_type is immutable and cannot be changed (\".concat(itemA._type, \" => \").concat(itemB._type, \")\"));\n  }\n  const operations = diffItem(itemA, itemB, options, basePath, []);\n  return serializePatches(operations, {\n    id,\n    ifRevisionID: revisionLocked ? ifRevisionID : void 0\n  });\n}\nfunction diffItem(itemA, itemB) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n  let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let patches = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  if (itemA === itemB) {\n    return patches;\n  }\n  const aType = Array.isArray(itemA) ? \"array\" : typeof itemA;\n  const bType = Array.isArray(itemB) ? \"array\" : typeof itemB;\n  const aIsUndefined = aType === \"undefined\";\n  const bIsUndefined = bType === \"undefined\";\n  if (aIsUndefined && !bIsUndefined) {\n    patches.push({\n      op: \"set\",\n      path,\n      value: itemB\n    });\n    return patches;\n  }\n  if (!aIsUndefined && bIsUndefined) {\n    patches.push({\n      op: \"unset\",\n      path\n    });\n    return patches;\n  }\n  const options = mergeOptions(opts);\n  const dataType = aIsUndefined ? bType : aType;\n  const isContainer = dataType === \"object\" || dataType === \"array\";\n  if (!isContainer) {\n    return diffPrimitive(itemA, itemB, options, path, patches);\n  }\n  if (aType !== bType) {\n    patches.push({\n      op: \"set\",\n      path,\n      value: itemB\n    });\n    return patches;\n  }\n  return dataType === \"array\" ? diffArray(itemA, itemB, options, path, patches) : diffObject(itemA, itemB, options, path, patches);\n}\nfunction diffObject(itemA, itemB, options, path, patches) {\n  const atRoot = path.length === 0;\n  const aKeys = Object.keys(itemA).filter(atRoot ? isNotIgnoredKey : yes).map(key => validateProperty(key, itemA[key], path));\n  const aKeysLength = aKeys.length;\n  const bKeys = Object.keys(itemB).filter(atRoot ? isNotIgnoredKey : yes).map(key => validateProperty(key, itemB[key], path));\n  const bKeysLength = bKeys.length;\n  for (let i = 0; i < aKeysLength; i++) {\n    const key = aKeys[i];\n    if (!(key in itemB)) {\n      patches.push({\n        op: \"unset\",\n        path: path.concat(key)\n      });\n    }\n  }\n  for (let i = 0; i < bKeysLength; i++) {\n    const key = bKeys[i];\n    diffItem(itemA[key], itemB[key], options, path.concat([key]), patches);\n  }\n  return patches;\n}\nfunction diffArray(itemA, itemB, options, path, patches) {\n  if (itemB.length > itemA.length) {\n    patches.push({\n      op: \"insert\",\n      after: path.concat([-1]),\n      items: itemB.slice(itemA.length).map((item, i) => nullifyUndefined(item, path, i, options))\n    });\n  }\n  if (itemB.length < itemA.length) {\n    const isSingle = itemA.length - itemB.length === 1;\n    const unsetItems = itemA.slice(itemB.length);\n    if (isRevisionLocked(options) || !isUniquelyKeyed(unsetItems)) {\n      patches.push({\n        op: \"unset\",\n        path: path.concat([isSingle ? itemB.length : [itemB.length, \"\"]])\n      });\n    } else {\n      patches.push(...unsetItems.map(item => ({\n        op: \"unset\",\n        path: path.concat({\n          _key: item._key\n        })\n      })));\n    }\n  }\n  for (let i = 0; i < itemB.length; i++) {\n    if (Array.isArray(itemB[i])) {\n      throw new DiffError(\"Multi-dimensional arrays not supported\", path.concat(i), itemB[i]);\n    }\n  }\n  const overlapping = Math.min(itemA.length, itemB.length);\n  const segmentA = itemA.slice(0, overlapping);\n  const segmentB = itemB.slice(0, overlapping);\n  return isUniquelyKeyed(segmentA) && isUniquelyKeyed(segmentB) ? diffArrayByKey(segmentA, segmentB, options, path, patches) : diffArrayByIndex(segmentA, segmentB, options, path, patches);\n}\nfunction diffArrayByIndex(itemA, itemB, options, path, patches) {\n  for (let i = 0; i < itemA.length; i++) {\n    diffItem(itemA[i], nullifyUndefined(itemB[i], path, i, options), options, path.concat(i), patches);\n  }\n  return patches;\n}\nfunction diffArrayByKey(itemA, itemB, options, path, patches) {\n  const keyedA = indexByKey(itemA);\n  const keyedB = indexByKey(itemB);\n  if (!arrayIsEqual(keyedA.keys, keyedB.keys)) {\n    return diffArrayByIndex(itemA, itemB, options, path, patches);\n  }\n  for (let i = 0; i < keyedB.keys.length; i++) {\n    const key = keyedB.keys[i];\n    const valueA = keyedA.index[key];\n    const valueB = nullifyUndefined(keyedB.index[key], path, i, options);\n    diffItem(valueA, valueB, options, path.concat({\n      _key: key\n    }), patches);\n  }\n  return patches;\n}\nfunction getDiffMatchPatch(itemA, itemB, options, path) {\n  const {\n    enabled,\n    lengthThresholdRelative,\n    lengthThresholdAbsolute\n  } = options.diffMatchPatch;\n  const segment = path[path.length - 1];\n  if (!enabled ||\n  // Don't use for anything but strings\n  typeof itemA !== \"string\" || typeof itemB !== \"string\" ||\n  // Don't use for `_key`, `_ref` etc\n  typeof segment === \"string\" && segment[0] === \"_\" ||\n  // Don't use on short strings\n  itemB.length < lengthThresholdAbsolute) {\n    return void 0;\n  }\n  let strPatch = \"\";\n  try {\n    const patch = diffMatchPatch.makeDiff(itemA, itemB);\n    const diff = diffMatchPatch.cleanupEfficiency(patch);\n    strPatch = diffMatchPatch.stringifyPatches(diffMatchPatch.makePatches(diff));\n  } catch (err) {\n    return void 0;\n  }\n  return strPatch.length > itemB.length * lengthThresholdRelative ? void 0 : {\n    op: \"diffMatchPatch\",\n    path,\n    value: strPatch\n  };\n}\nfunction diffPrimitive(itemA, itemB, options, path, patches) {\n  const dmp = getDiffMatchPatch(itemA, itemB, options, path);\n  patches.push(dmp || {\n    op: \"set\",\n    path,\n    value: itemB\n  });\n  return patches;\n}\nfunction isNotIgnoredKey(key) {\n  return ignoredKeys.indexOf(key) === -1;\n}\nfunction serializePatches(patches, options) {\n  if (patches.length === 0) {\n    return [];\n  }\n  const {\n    id,\n    ifRevisionID\n  } = options;\n  const set = patches.filter(patch => patch.op === \"set\");\n  const unset = patches.filter(patch => patch.op === \"unset\");\n  const insert = patches.filter(patch => patch.op === \"insert\");\n  const dmp = patches.filter(patch => patch.op === \"diffMatchPatch\");\n  const withSet = set.length > 0 && set.reduce((patch, item) => {\n    const path = pathToString(item.path);\n    patch.set[path] = item.value;\n    return patch;\n  }, {\n    id,\n    set: {}\n  });\n  const withUnset = unset.length > 0 && unset.reduce((patch, item) => {\n    const path = pathToString(item.path);\n    patch.unset.push(path);\n    return patch;\n  }, {\n    id,\n    unset: []\n  });\n  const withInsert = insert.reduce((acc, item) => {\n    const after = pathToString(item.after);\n    return acc.concat({\n      id,\n      insert: {\n        after,\n        items: item.items\n      }\n    });\n  }, []);\n  const withDmp = dmp.length > 0 && dmp.reduce((patch, item) => {\n    const path = pathToString(item.path);\n    patch.diffMatchPatch[path] = item.value;\n    return patch;\n  }, {\n    id,\n    diffMatchPatch: {}\n  });\n  const patchSet = [withSet, withUnset, withDmp, ...withInsert].filter(item => item !== false);\n  return patchSet.map((patch, i) => ({\n    patch: ifRevisionID && i === 0 ? {\n      ...patch,\n      ifRevisionID\n    } : patch\n  }));\n}\nfunction isUniquelyKeyed(arr) {\n  const keys = [];\n  for (let i = 0; i < arr.length; i++) {\n    const key = getKey(arr[i]);\n    if (!key || keys.indexOf(key) !== -1) {\n      return false;\n    }\n    keys.push(key);\n  }\n  return true;\n}\nfunction getKey(obj) {\n  return typeof obj === \"object\" && obj !== null && obj._key;\n}\nfunction indexByKey(arr) {\n  return arr.reduce((acc, item) => {\n    acc.keys.push(item._key);\n    acc.index[item._key] = item;\n    return acc;\n  }, {\n    keys: [],\n    index: {}\n  });\n}\nfunction arrayIsEqual(itemA, itemB) {\n  return itemA.length === itemB.length && itemA.every((item, i) => itemB[i] === item);\n}\nfunction nullifyUndefined(item, path, index, options) {\n  if (typeof item !== \"undefined\") {\n    return item;\n  }\n  if (!options.hideWarnings) {\n    const serializedPath = pathToString(path.concat(index));\n    console.warn(\"undefined value in array converted to null (at '\".concat(serializedPath, \"')\"));\n  }\n  return null;\n}\nfunction isRevisionLocked(options) {\n  return Boolean(options.ifRevisionID);\n}\nfunction yes(_) {\n  return true;\n}\nexports.DiffError = DiffError;\nexports.diffItem = diffItem;\nexports.diffPatch = diffPatch;\n//# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2FuaXR5LWRpZmYtcGF0Y2gvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscUJBQXFCLG1CQUFPLENBQUMsOEZBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zYW5pdHktYXBwLy4vbm9kZV9tb2R1bGVzL3Nhbml0eS1kaWZmLXBhdGNoL2Rpc3QvaW5kZXguY2pzP2UwNzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBkaWZmTWF0Y2hQYXRjaCA9IHJlcXVpcmUoJ0BzYW5pdHkvZGlmZi1tYXRjaC1wYXRjaCcpO1xuZnVuY3Rpb24gcGF0aFRvU3RyaW5nKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKCh0YXJnZXQsIHNlZ21lbnQsIGkpID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZWdtZW50KSkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRhcmdldCwgXCJbXCIpLmNvbmNhdChzZWdtZW50LmpvaW4oXCI6XCIpLCBcIl1cIik7XG4gICAgfVxuICAgIGlmIChpc0tleWVkT2JqZWN0KHNlZ21lbnQpKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGFyZ2V0LCBcIltfa2V5PT1cXFwiXCIpLmNvbmNhdChzZWdtZW50Ll9rZXksIFwiXFxcIl1cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRhcmdldCwgXCJbXCIpLmNvbmNhdChzZWdtZW50LCBcIl1cIik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gXCJzdHJpbmdcIiAmJiAvXlxcZCskLy50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGFyZ2V0LCBcIltcXFwiXCIpLmNvbmNhdChzZWdtZW50LCBcIlxcXCJdXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IHNlcGFyYXRvciA9IGkgPT09IDAgPyBcIlwiIDogXCIuXCI7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGFyZ2V0KS5jb25jYXQoc2VwYXJhdG9yKS5jb25jYXQoc2VnbWVudCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHBhdGggc2VnbWVudCBcXFwiXCIuY29uY2F0KHNlZ21lbnQsIFwiXFxcIlwiKSk7XG4gIH0sIFwiXCIpO1xufVxuZnVuY3Rpb24gaXNLZXllZE9iamVjdChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iai5fa2V5ID09PSBcInN0cmluZ1wiO1xufVxuY2xhc3MgRGlmZkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCB2YWx1ZSkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXRoID0gcGF0aFRvU3RyaW5nKHBhdGgpO1xuICAgIHN1cGVyKFwiXCIuY29uY2F0KG1lc3NhZ2UsIFwiIChhdCAnXCIpLmNvbmNhdChzZXJpYWxpemVkUGF0aCwgXCInKVwiKSk7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnNlcmlhbGl6ZWRQYXRoID0gc2VyaWFsaXplZFBhdGg7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG59XG5jb25zdCBpZFBhdHRlcm4gPSAvXlthLXowLTldW2EtejAtOV8uLV0rJC9pO1xuY29uc3QgcHJvcFBhdHRlcm4gPSAvXlthLXpBLVpfXVthLXpBLVowLTlfXSokLztcbmNvbnN0IHByb3BTdGFydFBhdHRlcm4gPSAvXlthLXpfXS9pO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIHBhdGgpIHtcbiAgaWYgKCFwcm9wU3RhcnRQYXR0ZXJuLnRlc3QocHJvcGVydHkpKSB7XG4gICAgdGhyb3cgbmV3IERpZmZFcnJvcihcIktleXMgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyIChhLXopXCIsIHBhdGguY29uY2F0KHByb3BlcnR5KSwgdmFsdWUpO1xuICB9XG4gIGlmICghcHJvcFBhdHRlcm4udGVzdChwcm9wZXJ0eSkpIHtcbiAgICB0aHJvdyBuZXcgRGlmZkVycm9yKFwiS2V5cyBjYW4gb25seSBjb250YWluIGxldHRlcnMsIG51bWJlcnMgYW5kIHVuZGVyc2NvcmVzXCIsIHBhdGguY29uY2F0KHByb3BlcnR5KSwgdmFsdWUpO1xuICB9XG4gIGlmIChwcm9wZXJ0eSA9PT0gXCJfa2V5XCIgfHwgcHJvcGVydHkgPT09IFwiX3JlZlwiIHx8IHByb3BlcnR5ID09PSBcIl90eXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRGlmZkVycm9yKFwiS2V5cyBtdXN0IGJlIHN0cmluZ3NcIiwgcGF0aC5jb25jYXQocHJvcGVydHkpLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICghaWRQYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRGlmZkVycm9yKFwiSW52YWxpZCBrZXkgLSB1c2UgbGVzcyBleG90aWMgY2hhcmFjdGVyc1wiLCBwYXRoLmNvbmNhdChwcm9wZXJ0eSksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5O1xufVxuY29uc3QgaWdub3JlZEtleXMgPSBbXCJfaWRcIiwgXCJfdHlwZVwiLCBcIl9jcmVhdGVkQXRcIiwgXCJfdXBkYXRlZEF0XCIsIFwiX3JldlwiXTtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBoaWRlV2FybmluZ3M6IGZhbHNlLFxuICBkaWZmTWF0Y2hQYXRjaDoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLy8gT25seSB1c2UgZGlmZi1tYXRjaC1wYXRjaCBpZiB0YXJnZXQgc3RyaW5nIGlzIGxvbmdlciB0aGFuIHRoaXMgdGhyZXNob2xkXG4gICAgbGVuZ3RoVGhyZXNob2xkQWJzb2x1dGU6IDMwLFxuICAgIC8vIE9ubHkgdXNlIGdlbmVyYXRlZCBkaWZmLW1hdGNoLXBhdGNoIGlmIHRoZSBwYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gICAgLy8gKHRhcmdldFN0cmluZyAqIHJlbGF0aXZlKS4gRXhhbXBsZTogQSAxMDAgY2hhcmFjdGVyIHRhcmdldCB3aXRoIGEgcmVsYXRpdmUgZmFjdG9yXG4gICAgLy8gb2YgMS4yIHdpbGwgYWxsb3cgYSAxMjAgY2hhcmFjdGVyIGRpZmYtbWF0Y2gtcGF0Y2guIElmIGxhcmdlciB0aGFuIHRoaXMgbnVtYmVyLFxuICAgIC8vIGl0IHdpbGwgZmFsbCBiYWNrIHRvIGEgcmVndWxhciBgc2V0YCBwYXRjaC5cbiAgICBsZW5ndGhUaHJlc2hvbGRSZWxhdGl2ZTogMS4yXG4gIH1cbn07XG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgZGlmZk1hdGNoUGF0Y2g6IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLmRpZmZNYXRjaFBhdGNoLFxuICAgICAgLi4uKG9wdGlvbnMuZGlmZk1hdGNoUGF0Y2ggfHwge30pXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGlmZlBhdGNoKGl0ZW1BLCBpdGVtQiwgb3B0cykge1xuICBjb25zdCBvcHRpb25zID0gbWVyZ2VPcHRpb25zKG9wdHMgfHwge30pO1xuICBjb25zdCBpZCA9IG9wdGlvbnMuaWQgfHwgaXRlbUEuX2lkID09PSBpdGVtQi5faWQgJiYgaXRlbUEuX2lkO1xuICBjb25zdCByZXZpc2lvbkxvY2tlZCA9IG9wdGlvbnMuaWZSZXZpc2lvbklEO1xuICBjb25zdCBpZlJldmlzaW9uSUQgPSB0eXBlb2YgcmV2aXNpb25Mb2NrZWQgPT09IFwiYm9vbGVhblwiID8gaXRlbUEuX3JldiA6IHJldmlzaW9uTG9ja2VkO1xuICBjb25zdCBiYXNlUGF0aCA9IG9wdGlvbnMuYmFzZVBhdGggfHwgW107XG4gIGlmICghaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJfaWQgb24gaXRlbUEgYW5kIGl0ZW1CIG5vdCBwcmVzZW50IG9yIGRpZmZlcnMsIHNwZWNpZnkgZG9jdW1lbnQgaWQgdGhlIG11dGF0aW9ucyBzaG91bGQgYmUgYXBwbGllZCB0b1wiKTtcbiAgfVxuICBpZiAocmV2aXNpb25Mb2NrZWQgPT09IHRydWUgJiYgIWlmUmV2aXNpb25JRCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImBpZlJldmlzaW9uSURgIGlzIHNldCB0byBgdHJ1ZWAsIGJ1dCBubyBgX3JldmAgd2FzIHBhc3NlZCBpbiBpdGVtIEEuIEVpdGhlciBleHBsaWNpdGx5IHNldCBgaWZSZXZpc2lvbklEYCB0byBhIHJldmlzaW9uLCBvciBwYXNzIGBfcmV2YCBhcyBwYXJ0IG9mIGl0ZW0gQS5cIik7XG4gIH1cbiAgaWYgKGJhc2VQYXRoLmxlbmd0aCA9PT0gMCAmJiBpdGVtQS5fdHlwZSAhPT0gaXRlbUIuX3R5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJfdHlwZSBpcyBpbW11dGFibGUgYW5kIGNhbm5vdCBiZSBjaGFuZ2VkIChcIi5jb25jYXQoaXRlbUEuX3R5cGUsIFwiID0+IFwiKS5jb25jYXQoaXRlbUIuX3R5cGUsIFwiKVwiKSk7XG4gIH1cbiAgY29uc3Qgb3BlcmF0aW9ucyA9IGRpZmZJdGVtKGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgYmFzZVBhdGgsIFtdKTtcbiAgcmV0dXJuIHNlcmlhbGl6ZVBhdGNoZXMob3BlcmF0aW9ucywge1xuICAgIGlkLFxuICAgIGlmUmV2aXNpb25JRDogcmV2aXNpb25Mb2NrZWQgPyBpZlJldmlzaW9uSUQgOiB2b2lkIDBcbiAgfSk7XG59XG5mdW5jdGlvbiBkaWZmSXRlbShpdGVtQSwgaXRlbUIpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGRlZmF1bHRPcHRpb25zO1xuICBsZXQgcGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogW107XG4gIGxldCBwYXRjaGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBbXTtcbiAgaWYgKGl0ZW1BID09PSBpdGVtQikge1xuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIGNvbnN0IGFUeXBlID0gQXJyYXkuaXNBcnJheShpdGVtQSkgPyBcImFycmF5XCIgOiB0eXBlb2YgaXRlbUE7XG4gIGNvbnN0IGJUeXBlID0gQXJyYXkuaXNBcnJheShpdGVtQikgPyBcImFycmF5XCIgOiB0eXBlb2YgaXRlbUI7XG4gIGNvbnN0IGFJc1VuZGVmaW5lZCA9IGFUeXBlID09PSBcInVuZGVmaW5lZFwiO1xuICBjb25zdCBiSXNVbmRlZmluZWQgPSBiVHlwZSA9PT0gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKGFJc1VuZGVmaW5lZCAmJiAhYklzVW5kZWZpbmVkKSB7XG4gICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBcInNldFwiLFxuICAgICAgcGF0aCxcbiAgICAgIHZhbHVlOiBpdGVtQlxuICAgIH0pO1xuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIGlmICghYUlzVW5kZWZpbmVkICYmIGJJc1VuZGVmaW5lZCkge1xuICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogXCJ1bnNldFwiLFxuICAgICAgcGF0aFxuICAgIH0pO1xuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0cyk7XG4gIGNvbnN0IGRhdGFUeXBlID0gYUlzVW5kZWZpbmVkID8gYlR5cGUgOiBhVHlwZTtcbiAgY29uc3QgaXNDb250YWluZXIgPSBkYXRhVHlwZSA9PT0gXCJvYmplY3RcIiB8fCBkYXRhVHlwZSA9PT0gXCJhcnJheVwiO1xuICBpZiAoIWlzQ29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGRpZmZQcmltaXRpdmUoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKTtcbiAgfVxuICBpZiAoYVR5cGUgIT09IGJUeXBlKSB7XG4gICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBcInNldFwiLFxuICAgICAgcGF0aCxcbiAgICAgIHZhbHVlOiBpdGVtQlxuICAgIH0pO1xuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIHJldHVybiBkYXRhVHlwZSA9PT0gXCJhcnJheVwiID8gZGlmZkFycmF5KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykgOiBkaWZmT2JqZWN0KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcyk7XG59XG5mdW5jdGlvbiBkaWZmT2JqZWN0KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykge1xuICBjb25zdCBhdFJvb3QgPSBwYXRoLmxlbmd0aCA9PT0gMDtcbiAgY29uc3QgYUtleXMgPSBPYmplY3Qua2V5cyhpdGVtQSkuZmlsdGVyKGF0Um9vdCA/IGlzTm90SWdub3JlZEtleSA6IHllcykubWFwKGtleSA9PiB2YWxpZGF0ZVByb3BlcnR5KGtleSwgaXRlbUFba2V5XSwgcGF0aCkpO1xuICBjb25zdCBhS2V5c0xlbmd0aCA9IGFLZXlzLmxlbmd0aDtcbiAgY29uc3QgYktleXMgPSBPYmplY3Qua2V5cyhpdGVtQikuZmlsdGVyKGF0Um9vdCA/IGlzTm90SWdub3JlZEtleSA6IHllcykubWFwKGtleSA9PiB2YWxpZGF0ZVByb3BlcnR5KGtleSwgaXRlbUJba2V5XSwgcGF0aCkpO1xuICBjb25zdCBiS2V5c0xlbmd0aCA9IGJLZXlzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhS2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gYUtleXNbaV07XG4gICAgaWYgKCEoa2V5IGluIGl0ZW1CKSkge1xuICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgb3A6IFwidW5zZXRcIixcbiAgICAgICAgcGF0aDogcGF0aC5jb25jYXQoa2V5KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYktleXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGJLZXlzW2ldO1xuICAgIGRpZmZJdGVtKGl0ZW1BW2tleV0sIGl0ZW1CW2tleV0sIG9wdGlvbnMsIHBhdGguY29uY2F0KFtrZXldKSwgcGF0Y2hlcyk7XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiBkaWZmQXJyYXkoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSB7XG4gIGlmIChpdGVtQi5sZW5ndGggPiBpdGVtQS5sZW5ndGgpIHtcbiAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFwiaW5zZXJ0XCIsXG4gICAgICBhZnRlcjogcGF0aC5jb25jYXQoWy0xXSksXG4gICAgICBpdGVtczogaXRlbUIuc2xpY2UoaXRlbUEubGVuZ3RoKS5tYXAoKGl0ZW0sIGkpID0+IG51bGxpZnlVbmRlZmluZWQoaXRlbSwgcGF0aCwgaSwgb3B0aW9ucykpXG4gICAgfSk7XG4gIH1cbiAgaWYgKGl0ZW1CLmxlbmd0aCA8IGl0ZW1BLmxlbmd0aCkge1xuICAgIGNvbnN0IGlzU2luZ2xlID0gaXRlbUEubGVuZ3RoIC0gaXRlbUIubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IHVuc2V0SXRlbXMgPSBpdGVtQS5zbGljZShpdGVtQi5sZW5ndGgpO1xuICAgIGlmIChpc1JldmlzaW9uTG9ja2VkKG9wdGlvbnMpIHx8ICFpc1VuaXF1ZWx5S2V5ZWQodW5zZXRJdGVtcykpIHtcbiAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBcInVuc2V0XCIsXG4gICAgICAgIHBhdGg6IHBhdGguY29uY2F0KFtpc1NpbmdsZSA/IGl0ZW1CLmxlbmd0aCA6IFtpdGVtQi5sZW5ndGgsIFwiXCJdXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaGVzLnB1c2goLi4udW5zZXRJdGVtcy5tYXAoaXRlbSA9PiAoe1xuICAgICAgICBvcDogXCJ1bnNldFwiLFxuICAgICAgICBwYXRoOiBwYXRoLmNvbmNhdCh7XG4gICAgICAgICAgX2tleTogaXRlbS5fa2V5XG4gICAgICAgIH0pXG4gICAgICB9KSkpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1CLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbUJbaV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRGlmZkVycm9yKFwiTXVsdGktZGltZW5zaW9uYWwgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgcGF0aC5jb25jYXQoaSksIGl0ZW1CW2ldKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb3ZlcmxhcHBpbmcgPSBNYXRoLm1pbihpdGVtQS5sZW5ndGgsIGl0ZW1CLmxlbmd0aCk7XG4gIGNvbnN0IHNlZ21lbnRBID0gaXRlbUEuc2xpY2UoMCwgb3ZlcmxhcHBpbmcpO1xuICBjb25zdCBzZWdtZW50QiA9IGl0ZW1CLnNsaWNlKDAsIG92ZXJsYXBwaW5nKTtcbiAgcmV0dXJuIGlzVW5pcXVlbHlLZXllZChzZWdtZW50QSkgJiYgaXNVbmlxdWVseUtleWVkKHNlZ21lbnRCKSA/IGRpZmZBcnJheUJ5S2V5KHNlZ21lbnRBLCBzZWdtZW50Qiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykgOiBkaWZmQXJyYXlCeUluZGV4KHNlZ21lbnRBLCBzZWdtZW50Qiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcyk7XG59XG5mdW5jdGlvbiBkaWZmQXJyYXlCeUluZGV4KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1BLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlmZkl0ZW0oaXRlbUFbaV0sIG51bGxpZnlVbmRlZmluZWQoaXRlbUJbaV0sIHBhdGgsIGksIG9wdGlvbnMpLCBvcHRpb25zLCBwYXRoLmNvbmNhdChpKSwgcGF0Y2hlcyk7XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiBkaWZmQXJyYXlCeUtleShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIHtcbiAgY29uc3Qga2V5ZWRBID0gaW5kZXhCeUtleShpdGVtQSk7XG4gIGNvbnN0IGtleWVkQiA9IGluZGV4QnlLZXkoaXRlbUIpO1xuICBpZiAoIWFycmF5SXNFcXVhbChrZXllZEEua2V5cywga2V5ZWRCLmtleXMpKSB7XG4gICAgcmV0dXJuIGRpZmZBcnJheUJ5SW5kZXgoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleWVkQi5rZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5ZWRCLmtleXNbaV07XG4gICAgY29uc3QgdmFsdWVBID0ga2V5ZWRBLmluZGV4W2tleV07XG4gICAgY29uc3QgdmFsdWVCID0gbnVsbGlmeVVuZGVmaW5lZChrZXllZEIuaW5kZXhba2V5XSwgcGF0aCwgaSwgb3B0aW9ucyk7XG4gICAgZGlmZkl0ZW0odmFsdWVBLCB2YWx1ZUIsIG9wdGlvbnMsIHBhdGguY29uY2F0KHtcbiAgICAgIF9rZXk6IGtleVxuICAgIH0pLCBwYXRjaGVzKTtcbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn1cbmZ1bmN0aW9uIGdldERpZmZNYXRjaFBhdGNoKGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCkge1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCxcbiAgICBsZW5ndGhUaHJlc2hvbGRSZWxhdGl2ZSxcbiAgICBsZW5ndGhUaHJlc2hvbGRBYnNvbHV0ZVxuICB9ID0gb3B0aW9ucy5kaWZmTWF0Y2hQYXRjaDtcbiAgY29uc3Qgc2VnbWVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgaWYgKCFlbmFibGVkIHx8XG4gIC8vIERvbid0IHVzZSBmb3IgYW55dGhpbmcgYnV0IHN0cmluZ3NcbiAgdHlwZW9mIGl0ZW1BICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBpdGVtQiAhPT0gXCJzdHJpbmdcIiB8fFxuICAvLyBEb24ndCB1c2UgZm9yIGBfa2V5YCwgYF9yZWZgIGV0Y1xuICB0eXBlb2Ygc2VnbWVudCA9PT0gXCJzdHJpbmdcIiAmJiBzZWdtZW50WzBdID09PSBcIl9cIiB8fFxuICAvLyBEb24ndCB1c2Ugb24gc2hvcnQgc3RyaW5nc1xuICBpdGVtQi5sZW5ndGggPCBsZW5ndGhUaHJlc2hvbGRBYnNvbHV0ZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IHN0clBhdGNoID0gXCJcIjtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXRjaCA9IGRpZmZNYXRjaFBhdGNoLm1ha2VEaWZmKGl0ZW1BLCBpdGVtQik7XG4gICAgY29uc3QgZGlmZiA9IGRpZmZNYXRjaFBhdGNoLmNsZWFudXBFZmZpY2llbmN5KHBhdGNoKTtcbiAgICBzdHJQYXRjaCA9IGRpZmZNYXRjaFBhdGNoLnN0cmluZ2lmeVBhdGNoZXMoZGlmZk1hdGNoUGF0Y2gubWFrZVBhdGNoZXMoZGlmZikpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBzdHJQYXRjaC5sZW5ndGggPiBpdGVtQi5sZW5ndGggKiBsZW5ndGhUaHJlc2hvbGRSZWxhdGl2ZSA/IHZvaWQgMCA6IHtcbiAgICBvcDogXCJkaWZmTWF0Y2hQYXRjaFwiLFxuICAgIHBhdGgsXG4gICAgdmFsdWU6IHN0clBhdGNoXG4gIH07XG59XG5mdW5jdGlvbiBkaWZmUHJpbWl0aXZlKGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykge1xuICBjb25zdCBkbXAgPSBnZXREaWZmTWF0Y2hQYXRjaChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgpO1xuICBwYXRjaGVzLnB1c2goZG1wIHx8IHtcbiAgICBvcDogXCJzZXRcIixcbiAgICBwYXRoLFxuICAgIHZhbHVlOiBpdGVtQlxuICB9KTtcbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiBpc05vdElnbm9yZWRLZXkoa2V5KSB7XG4gIHJldHVybiBpZ25vcmVkS2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplUGF0Y2hlcyhwYXRjaGVzLCBvcHRpb25zKSB7XG4gIGlmIChwYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCB7XG4gICAgaWQsXG4gICAgaWZSZXZpc2lvbklEXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBzZXQgPSBwYXRjaGVzLmZpbHRlcihwYXRjaCA9PiBwYXRjaC5vcCA9PT0gXCJzZXRcIik7XG4gIGNvbnN0IHVuc2V0ID0gcGF0Y2hlcy5maWx0ZXIocGF0Y2ggPT4gcGF0Y2gub3AgPT09IFwidW5zZXRcIik7XG4gIGNvbnN0IGluc2VydCA9IHBhdGNoZXMuZmlsdGVyKHBhdGNoID0+IHBhdGNoLm9wID09PSBcImluc2VydFwiKTtcbiAgY29uc3QgZG1wID0gcGF0Y2hlcy5maWx0ZXIocGF0Y2ggPT4gcGF0Y2gub3AgPT09IFwiZGlmZk1hdGNoUGF0Y2hcIik7XG4gIGNvbnN0IHdpdGhTZXQgPSBzZXQubGVuZ3RoID4gMCAmJiBzZXQucmVkdWNlKChwYXRjaCwgaXRlbSkgPT4ge1xuICAgIGNvbnN0IHBhdGggPSBwYXRoVG9TdHJpbmcoaXRlbS5wYXRoKTtcbiAgICBwYXRjaC5zZXRbcGF0aF0gPSBpdGVtLnZhbHVlO1xuICAgIHJldHVybiBwYXRjaDtcbiAgfSwge1xuICAgIGlkLFxuICAgIHNldDoge31cbiAgfSk7XG4gIGNvbnN0IHdpdGhVbnNldCA9IHVuc2V0Lmxlbmd0aCA+IDAgJiYgdW5zZXQucmVkdWNlKChwYXRjaCwgaXRlbSkgPT4ge1xuICAgIGNvbnN0IHBhdGggPSBwYXRoVG9TdHJpbmcoaXRlbS5wYXRoKTtcbiAgICBwYXRjaC51bnNldC5wdXNoKHBhdGgpO1xuICAgIHJldHVybiBwYXRjaDtcbiAgfSwge1xuICAgIGlkLFxuICAgIHVuc2V0OiBbXVxuICB9KTtcbiAgY29uc3Qgd2l0aEluc2VydCA9IGluc2VydC5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgIGNvbnN0IGFmdGVyID0gcGF0aFRvU3RyaW5nKGl0ZW0uYWZ0ZXIpO1xuICAgIHJldHVybiBhY2MuY29uY2F0KHtcbiAgICAgIGlkLFxuICAgICAgaW5zZXJ0OiB7XG4gICAgICAgIGFmdGVyLFxuICAgICAgICBpdGVtczogaXRlbS5pdGVtc1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHdpdGhEbXAgPSBkbXAubGVuZ3RoID4gMCAmJiBkbXAucmVkdWNlKChwYXRjaCwgaXRlbSkgPT4ge1xuICAgIGNvbnN0IHBhdGggPSBwYXRoVG9TdHJpbmcoaXRlbS5wYXRoKTtcbiAgICBwYXRjaC5kaWZmTWF0Y2hQYXRjaFtwYXRoXSA9IGl0ZW0udmFsdWU7XG4gICAgcmV0dXJuIHBhdGNoO1xuICB9LCB7XG4gICAgaWQsXG4gICAgZGlmZk1hdGNoUGF0Y2g6IHt9XG4gIH0pO1xuICBjb25zdCBwYXRjaFNldCA9IFt3aXRoU2V0LCB3aXRoVW5zZXQsIHdpdGhEbXAsIC4uLndpdGhJbnNlcnRdLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IGZhbHNlKTtcbiAgcmV0dXJuIHBhdGNoU2V0Lm1hcCgocGF0Y2gsIGkpID0+ICh7XG4gICAgcGF0Y2g6IGlmUmV2aXNpb25JRCAmJiBpID09PSAwID8ge1xuICAgICAgLi4ucGF0Y2gsXG4gICAgICBpZlJldmlzaW9uSURcbiAgICB9IDogcGF0Y2hcbiAgfSkpO1xufVxuZnVuY3Rpb24gaXNVbmlxdWVseUtleWVkKGFycikge1xuICBjb25zdCBrZXlzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KGFycltpXSk7XG4gICAgaWYgKCFrZXkgfHwga2V5cy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0S2V5KG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwgJiYgb2JqLl9rZXk7XG59XG5mdW5jdGlvbiBpbmRleEJ5S2V5KGFycikge1xuICByZXR1cm4gYXJyLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgYWNjLmtleXMucHVzaChpdGVtLl9rZXkpO1xuICAgIGFjYy5pbmRleFtpdGVtLl9rZXldID0gaXRlbTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7XG4gICAga2V5czogW10sXG4gICAgaW5kZXg6IHt9XG4gIH0pO1xufVxuZnVuY3Rpb24gYXJyYXlJc0VxdWFsKGl0ZW1BLCBpdGVtQikge1xuICByZXR1cm4gaXRlbUEubGVuZ3RoID09PSBpdGVtQi5sZW5ndGggJiYgaXRlbUEuZXZlcnkoKGl0ZW0sIGkpID0+IGl0ZW1CW2ldID09PSBpdGVtKTtcbn1cbmZ1bmN0aW9uIG51bGxpZnlVbmRlZmluZWQoaXRlbSwgcGF0aCwgaW5kZXgsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBpdGVtICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgaWYgKCFvcHRpb25zLmhpZGVXYXJuaW5ncykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXRoID0gcGF0aFRvU3RyaW5nKHBhdGguY29uY2F0KGluZGV4KSk7XG4gICAgY29uc29sZS53YXJuKFwidW5kZWZpbmVkIHZhbHVlIGluIGFycmF5IGNvbnZlcnRlZCB0byBudWxsIChhdCAnXCIuY29uY2F0KHNlcmlhbGl6ZWRQYXRoLCBcIicpXCIpKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzUmV2aXNpb25Mb2NrZWQob3B0aW9ucykge1xuICByZXR1cm4gQm9vbGVhbihvcHRpb25zLmlmUmV2aXNpb25JRCk7XG59XG5mdW5jdGlvbiB5ZXMoXykge1xuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuRGlmZkVycm9yID0gRGlmZkVycm9yO1xuZXhwb3J0cy5kaWZmSXRlbSA9IGRpZmZJdGVtO1xuZXhwb3J0cy5kaWZmUGF0Y2ggPSBkaWZmUGF0Y2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sanity-diff-patch/dist/index.cjs\n");

/***/ })

};
;