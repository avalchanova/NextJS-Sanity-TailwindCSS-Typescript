"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mendoza";
exports.ids = ["vendor-chunks/mendoza"];
exports.modules = {

/***/ "(ssr)/./node_modules/mendoza/dist/index.cjs":
/*!*********************************************!*\
  !*** ./node_modules/mendoza/dist/index.cjs ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst OPS = [\"Value\", \"Copy\", \"Blank\", \"ReturnIntoArray\", \"ReturnIntoObject\", \"ReturnIntoObjectSameKey\", \"PushField\", \"PushElement\", \"PushParent\", \"Pop\", \"PushFieldCopy\", \"PushFieldBlank\", \"PushElementCopy\", \"PushElementBlank\", \"ReturnIntoObjectPop\", \"ReturnIntoObjectSameKeyPop\", \"ReturnIntoArrayPop\", \"ObjectSetFieldValue\", \"ObjectCopyField\", \"ObjectDeleteField\", \"ArrayAppendValue\", \"ArrayAppendSlice\", \"StringAppendString\", \"StringAppendSlice\"];\nclass Patcher {\n  constructor(model, root, patch) {\n    __publicField$1(this, \"model\");\n    __publicField$1(this, \"root\");\n    __publicField$1(this, \"patch\");\n    __publicField$1(this, \"i\");\n    __publicField$1(this, \"inputStack\");\n    __publicField$1(this, \"outputStack\");\n    this.model = model;\n    this.root = root;\n    this.patch = patch;\n    this.i = 0;\n    this.inputStack = [];\n    this.outputStack = [];\n  }\n  read() {\n    return this.patch[this.i++];\n  }\n  process() {\n    this.inputStack.push({\n      value: this.root\n    });\n    this.outputStack.push({\n      value: this.root\n    });\n    for (; this.i < this.patch.length;) {\n      let opcode = this.read();\n      let op = OPS[opcode];\n      if (!op) throw new Error(\"Unknown opcode: \".concat(opcode));\n      let processor = \"process\".concat(op);\n      this[processor].apply(this);\n    }\n    let entry = this.outputStack.pop();\n    return this.finalizeOutput(entry);\n  }\n  inputEntry() {\n    return this.inputStack[this.inputStack.length - 1];\n  }\n  inputKey(entry, idx) {\n    if (!entry.keys) {\n      entry.keys = this.model.objectGetKeys(entry.value).sort();\n    }\n    return entry.keys[idx];\n  }\n  outputEntry() {\n    return this.outputStack[this.outputStack.length - 1];\n  }\n  outputArray() {\n    let entry = this.outputEntry();\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyArray(entry.value);\n    }\n    return entry.writeValue;\n  }\n  outputObject() {\n    let entry = this.outputEntry();\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyObject(entry.value);\n    }\n    return entry.writeValue;\n  }\n  outputString() {\n    let entry = this.outputEntry();\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyString(entry.value);\n    }\n    return entry.writeValue;\n  }\n  finalizeOutput(entry) {\n    if (entry.writeValue) {\n      return this.model.finalize(entry.writeValue);\n    } else {\n      return entry.value;\n    }\n  }\n  // Processors:\n  processValue() {\n    let value = this.model.wrap(this.read());\n    this.outputStack.push({\n      value\n    });\n  }\n  processCopy() {\n    let input = this.inputEntry();\n    this.outputStack.push({\n      value: input.value\n    });\n  }\n  processBlank() {\n    this.outputStack.push({\n      value: null\n    });\n  }\n  processReturnIntoArray() {\n    let entry = this.outputStack.pop();\n    let result = this.finalizeOutput(entry);\n    let arr = this.outputArray();\n    this.model.arrayAppendValue(arr, result);\n  }\n  processReturnIntoObject() {\n    let key = this.read();\n    let entry = this.outputStack.pop();\n    let result = this.finalizeOutput(entry);\n    result = this.model.markChanged(result);\n    let obj = this.outputObject();\n    this.model.objectSetField(obj, key, result);\n  }\n  processReturnIntoObjectSameKey() {\n    let input = this.inputEntry();\n    let entry = this.outputStack.pop();\n    let result = this.finalizeOutput(entry);\n    let obj = this.outputObject();\n    this.model.objectSetField(obj, input.key, result);\n  }\n  processPushField() {\n    let idx = this.read();\n    let entry = this.inputEntry();\n    let key = this.inputKey(entry, idx);\n    let value = this.model.objectGetField(entry.value, key);\n    this.inputStack.push({\n      value,\n      key\n    });\n  }\n  processPushElement() {\n    let idx = this.read();\n    let entry = this.inputEntry();\n    let value = this.model.arrayGetElement(entry.value, idx);\n    this.inputStack.push({\n      value\n    });\n  }\n  processPop() {\n    this.inputStack.pop();\n  }\n  processPushFieldCopy() {\n    this.processPushField();\n    this.processCopy();\n  }\n  processPushFieldBlank() {\n    this.processPushField();\n    this.processBlank();\n  }\n  processPushElementCopy() {\n    this.processPushElement();\n    this.processCopy();\n  }\n  processPushElementBlank() {\n    this.processPushElement();\n    this.processBlank();\n  }\n  processReturnIntoObjectPop() {\n    this.processReturnIntoObject();\n    this.processPop();\n  }\n  processReturnIntoObjectSameKeyPop() {\n    this.processReturnIntoObjectSameKey();\n    this.processPop();\n  }\n  processReturnIntoArrayPop() {\n    this.processReturnIntoArray();\n    this.processPop();\n  }\n  processObjectSetFieldValue() {\n    this.processValue();\n    this.processReturnIntoObject();\n  }\n  processObjectCopyField() {\n    this.processPushField();\n    this.processCopy();\n    this.processReturnIntoObjectSameKey();\n    this.processPop();\n  }\n  processObjectDeleteField() {\n    let idx = this.read();\n    let entry = this.inputEntry();\n    let key = this.inputKey(entry, idx);\n    let obj = this.outputObject();\n    this.model.objectDeleteField(obj, key);\n  }\n  processArrayAppendValue() {\n    let value = this.model.wrap(this.read());\n    let arr = this.outputArray();\n    this.model.arrayAppendValue(arr, value);\n  }\n  processArrayAppendSlice() {\n    let left = this.read();\n    let right = this.read();\n    let str = this.outputArray();\n    let val = this.inputEntry().value;\n    this.model.arrayAppendSlice(str, val, left, right);\n  }\n  processStringAppendString() {\n    let value = this.model.wrap(this.read());\n    let str = this.outputString();\n    this.model.stringAppendValue(str, value);\n  }\n  processStringAppendSlice() {\n    let left = this.read();\n    let right = this.read();\n    let str = this.outputString();\n    let val = this.inputEntry().value;\n    this.model.stringAppendSlice(str, val, left, right);\n  }\n}\nfunction utf8charSize(code) {\n  if (code >> 16) {\n    return 4;\n  } else if (code >> 11) {\n    return 3;\n  } else if (code >> 7) {\n    return 2;\n  } else {\n    return 1;\n  }\n}\nfunction utf8stringSize(str) {\n  let b = 0;\n  for (let i = 0; i < str.length; i++) {\n    let code = str.codePointAt(i);\n    let size = utf8charSize(code);\n    if (size == 4) i++;\n    b += size;\n  }\n  return b;\n}\nfunction utf8resolveIndex(str, idx) {\n  let start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let byteCount = start;\n  let ucsIdx = 0;\n  for (ucsIdx = start; byteCount < idx; ucsIdx++) {\n    let code = str.codePointAt(ucsIdx);\n    let size = utf8charSize(code);\n    if (size === 4) ucsIdx++;\n    byteCount += size;\n  }\n  return ucsIdx;\n}\nfunction commonPrefix(str, str2) {\n  let len = Math.min(str.length, str2.length);\n  let b = 0;\n  for (let i = 0; i < len;) {\n    let aPoint = str.codePointAt(i);\n    let bPoint = str2.codePointAt(i);\n    if (aPoint !== bPoint) return b;\n    let size = utf8charSize(aPoint);\n    b += size;\n    i += size === 4 ? 2 : 1;\n  }\n  return b;\n}\nfunction commonSuffix(str, str2) {\n  let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let len = Math.min(str.length, str2.length) - prefix;\n  let b = 0;\n  for (let i = 0; i < len;) {\n    let aPoint = str.codePointAt(str.length - 1 - i);\n    let bPoint = str2.codePointAt(str2.length - 1 - i);\n    if (aPoint !== bPoint) return b;\n    let size = utf8charSize(aPoint);\n    b += size;\n    i += size === 4 ? 2 : 1;\n  }\n  return b;\n}\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass IncrementalModel {\n  constructor(meta) {\n    __publicField(this, \"meta\");\n    this.meta = meta;\n  }\n  wrap(data) {\n    return this.wrapWithMeta(data, this.meta, this.meta);\n  }\n  wrapWithMeta(data, startMeta) {\n    let endMeta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.meta;\n    return {\n      data,\n      startMeta,\n      endMeta\n    };\n  }\n  asObject(value) {\n    if (!value.content) {\n      let fields = {};\n      for (let [key, val] of Object.entries(value.data)) {\n        fields[key] = this.wrapWithMeta(val, value.startMeta);\n      }\n      value.content = {\n        type: \"object\",\n        fields\n      };\n    }\n    return value.content;\n  }\n  asArray(value) {\n    if (!value.content) {\n      let elements = value.data.map(item => this.wrapWithMeta(item, value.startMeta));\n      let metas = elements.map(() => this.meta);\n      value.content = {\n        type: \"array\",\n        elements,\n        metas\n      };\n    }\n    return value.content;\n  }\n  asString(value) {\n    if (!value.content) {\n      let str = value.data;\n      let part = {\n        value: str,\n        utf8size: utf8stringSize(str),\n        uses: [],\n        startMeta: value.startMeta,\n        endMeta: value.endMeta\n      };\n      value.content = this.stringFromParts([part]);\n    }\n    return value.content;\n  }\n  stringFromParts(parts) {\n    let str = {\n      type: \"string\",\n      parts\n    };\n    for (let part of parts) {\n      part.uses.push(str);\n    }\n    return str;\n  }\n  objectGetKeys(value) {\n    if (value.content) {\n      return Object.keys(value.content.fields);\n    } else {\n      return Object.keys(value.data);\n    }\n  }\n  objectGetField(value, key) {\n    let obj = this.asObject(value);\n    return obj.fields[key];\n  }\n  arrayGetElement(value, idx) {\n    let arr = this.asArray(value);\n    return arr.elements[idx];\n  }\n  finalize(content) {\n    this.updateEndMeta(content);\n    return {\n      content,\n      startMeta: this.meta,\n      endMeta: this.meta\n    };\n  }\n  markChanged(value) {\n    return this.wrap(unwrap(value));\n  }\n  updateEndMeta(content) {\n    if (content.type == \"string\") {\n      for (let part of content.parts) {\n        part.endMeta = this.meta;\n      }\n    } else {\n      if (content.type === \"array\") {\n        for (let val of content.elements) {\n          if (val.content && val.endMeta !== this.meta) {\n            this.updateEndMeta(val.content);\n          }\n          val.endMeta = this.meta;\n        }\n      } else {\n        for (let val of Object.values(content.fields)) {\n          if (val.content && val.endMeta !== this.meta) {\n            this.updateEndMeta(val.content);\n          }\n          val.endMeta = this.meta;\n        }\n      }\n    }\n  }\n  copyString(value) {\n    if (value) {\n      let other = this.asString(value);\n      return this.stringFromParts(other.parts.slice());\n    } else {\n      return {\n        type: \"string\",\n        parts: []\n      };\n    }\n  }\n  copyObject(value) {\n    let obj = {\n      type: \"object\",\n      fields: {}\n    };\n    if (value) {\n      let other = this.asObject(value);\n      Object.assign(obj.fields, other.fields);\n    }\n    return obj;\n  }\n  copyArray(value) {\n    let arr = value ? this.asArray(value) : null;\n    let elements = arr ? arr.elements : [];\n    let metas = arr ? arr.metas : [];\n    return {\n      type: \"array\",\n      elements,\n      metas\n    };\n  }\n  objectSetField(target, key, value) {\n    target.fields[key] = value;\n  }\n  objectDeleteField(target, key) {\n    delete target.fields[key];\n  }\n  arrayAppendValue(target, value) {\n    target.elements.push(value);\n    target.metas.push(this.meta);\n  }\n  arrayAppendSlice(target, source, left, right) {\n    let arr = this.asArray(source);\n    let samePosition = arr.elements.length === left;\n    target.elements.push(...arr.elements.slice(left, right));\n    if (samePosition) {\n      target.metas.push(...arr.metas.slice(left, right));\n    } else {\n      for (let i = left; i < right; i++) {\n        target.metas.push(this.meta);\n      }\n    }\n  }\n  stringAppendValue(target, value) {\n    let str = this.asString(value);\n    for (let part of str.parts) {\n      this.stringAppendPart(target, part);\n    }\n  }\n  stringAppendPart(target, part) {\n    target.parts.push(part);\n    part.uses.push(target);\n  }\n  resolveStringPart(str, from, len) {\n    if (len === 0) return from;\n    for (let i = from; i < str.parts.length; i++) {\n      let part = str.parts[i];\n      if (len === part.utf8size) {\n        return i + 1;\n      }\n      if (len < part.utf8size) {\n        this.splitString(part, len);\n        return i + 1;\n      }\n      len -= part.utf8size;\n    }\n    throw new Error(\"splitting string out of bounds\");\n  }\n  splitString(part, idx) {\n    let leftValue;\n    let rightValue;\n    let leftSize = idx;\n    let rightSize = part.utf8size - leftSize;\n    if (part.utf8size !== part.value.length) {\n      let byteCount = 0;\n      for (idx = 0; byteCount < leftSize; idx++) {\n        let code = part.value.codePointAt(idx);\n        let size = utf8charSize(code);\n        if (size === 4) idx++;\n        byteCount += size;\n      }\n    }\n    leftValue = part.value.slice(0, idx);\n    rightValue = part.value.slice(idx);\n    let newPart = {\n      value: rightValue,\n      utf8size: rightSize,\n      uses: part.uses.slice(),\n      startMeta: part.startMeta,\n      endMeta: part.endMeta\n    };\n    part.value = leftValue;\n    part.utf8size = leftSize;\n    for (let use of part.uses) {\n      let ndx = use.parts.indexOf(part);\n      if (ndx === -1) throw new Error(\"bug: mismatch between string parts and use.\");\n      use.parts.splice(ndx + 1, 0, newPart);\n    }\n  }\n  stringAppendSlice(target, source, left, right) {\n    let str = this.asString(source);\n    let firstPart = this.resolveStringPart(str, 0, left);\n    let lastPart = this.resolveStringPart(str, firstPart, right - left);\n    for (let i = firstPart; i < lastPart; i++) {\n      let part = str.parts[i];\n      this.stringAppendPart(target, part);\n    }\n  }\n}\nfunction wrap(data, meta) {\n  return {\n    data,\n    startMeta: meta,\n    endMeta: meta\n  };\n}\nfunction unwrap(value) {\n  if (typeof value.data !== \"undefined\") return value.data;\n  let result;\n  let content = value.content;\n  switch (content.type) {\n    case \"string\":\n      result = content.parts.map(part => part.value).join(\"\");\n      break;\n    case \"array\":\n      result = content.elements.map(val => unwrap(val));\n      break;\n    case \"object\":\n      {\n        result = {};\n        for (let [key, val] of Object.entries(content.fields)) {\n          result[key] = unwrap(val);\n        }\n      }\n  }\n  value.data = result;\n  return result;\n}\nfunction getType(value) {\n  if (value.content) return value.content.type;\n  if (Array.isArray(value.data)) return \"array\";\n  if (value.data === null) return \"null\";\n  return typeof value.data;\n}\nfunction rebaseValue(left, right) {\n  let leftType = getType(left);\n  let rightType = getType(right);\n  if (leftType !== rightType) return right;\n  let leftModel = new IncrementalModel(left.endMeta);\n  let rightModel = new IncrementalModel(right.endMeta);\n  switch (leftType) {\n    case \"object\":\n      {\n        let leftObj = leftModel.asObject(left);\n        let rightObj = rightModel.asObject(right);\n        let identicalFieldCount = 0;\n        let leftFieldCount = Object.keys(leftObj.fields).length;\n        let rightFieldCount = Object.keys(rightObj.fields).length;\n        for (let [key, rightVal] of Object.entries(rightObj.fields)) {\n          let leftVal = leftObj.fields[key];\n          if (leftVal) {\n            rightObj.fields[key] = rebaseValue(leftVal, rightVal);\n            if (rightObj.fields[key] === leftVal) {\n              identicalFieldCount++;\n            }\n          }\n        }\n        let isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;\n        return isIdentical ? left : right;\n      }\n    case \"array\":\n      {\n        let leftArr = leftModel.asArray(left);\n        let rightArr = rightModel.asArray(right);\n        if (leftArr.elements.length !== rightArr.elements.length) {\n          break;\n        }\n        let numRebased = 0;\n        for (let i = 0; i < rightArr.elements.length; i++) {\n          rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);\n          if (rightArr.elements[i] !== leftArr.elements[i]) {\n            numRebased++;\n          }\n        }\n        return numRebased === 0 ? left : right;\n      }\n    case \"null\":\n    case \"boolean\":\n    case \"number\":\n      {\n        if (unwrap(left) === unwrap(right)) return left;\n        break;\n      }\n    case \"string\":\n      {\n        let leftRaw = unwrap(left);\n        let rightRaw = unwrap(right);\n        if (leftRaw === rightRaw) return left;\n        let result = rightModel.copyString(null);\n        let prefix = commonPrefix(leftRaw, rightRaw);\n        let suffix = commonSuffix(leftRaw, rightRaw, prefix);\n        let rightLen = utf8stringSize(rightRaw);\n        let leftLen = utf8stringSize(leftRaw);\n        if (0 < prefix) {\n          rightModel.stringAppendSlice(result, left, 0, prefix);\n        }\n        if (prefix < rightLen - suffix) {\n          rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);\n        }\n        if (leftLen - suffix < leftLen) {\n          rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);\n        }\n        let value = rightModel.finalize(result);\n        if (unwrap(value) !== rightRaw) throw new Error(\"incorrect string rebase\");\n        return value;\n      }\n  }\n  return right;\n}\nfunction applyPatch$1(left, patch, startMeta) {\n  let model = new IncrementalModel(startMeta);\n  let patcher = new Patcher(model, left, patch);\n  return patcher.process();\n}\nvar incrementalPatcher = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  applyPatch: applyPatch$1,\n  getType: getType,\n  rebaseValue: rebaseValue,\n  unwrap: unwrap,\n  wrap: wrap\n});\nclass SimpleModel {\n  wrap(data) {\n    return data;\n  }\n  finalize(b) {\n    if (Array.isArray(b)) {\n      return b;\n    } else {\n      return b.data;\n    }\n  }\n  markChanged(value) {\n    return value;\n  }\n  objectGetKeys(value) {\n    return Object.keys(value);\n  }\n  objectGetField(value, key) {\n    return value[key];\n  }\n  arrayGetElement(value, idx) {\n    return value[idx];\n  }\n  copyObject(value) {\n    let res = {\n      type: \"object\",\n      data: {}\n    };\n    if (value !== null) {\n      for (let [key, val] of Object.entries(value)) {\n        res.data[key] = val;\n      }\n    }\n    return res;\n  }\n  copyArray(value) {\n    if (value === null) return [];\n    return value.slice();\n  }\n  copyString(value) {\n    return {\n      type: \"string\",\n      data: value === null ? \"\" : value\n    };\n  }\n  objectSetField(target, key, value) {\n    target.data[key] = value;\n  }\n  objectDeleteField(target, key) {\n    delete target.data[key];\n  }\n  arrayAppendValue(target, value) {\n    target.push(value);\n  }\n  arrayAppendSlice(target, source, left, right) {\n    target.push(...source.slice(left, right));\n  }\n  stringAppendSlice(target, source, left, right) {\n    const sourceString = source;\n    const leftPos = utf8resolveIndex(sourceString, left);\n    const rightPos = utf8resolveIndex(sourceString, right, leftPos);\n    target.data += sourceString.slice(leftPos, rightPos);\n  }\n  stringAppendValue(target, value) {\n    target.data += value;\n  }\n}\nfunction applyPatch(left, patch) {\n  let root = left;\n  let patcher = new Patcher(new SimpleModel(), root, patch);\n  return patcher.process();\n}\nexports.applyPatch = applyPatch;\nexports.incremental = incrementalPatcher;\n//# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9kaXN0L2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zYW5pdHktYXBwLy4vbm9kZV9tb2R1bGVzL21lbmRvemEvZGlzdC9pbmRleC5janM/YzU0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIF9fZGVmUHJvcCQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkMShvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBPUFMgPSBbXCJWYWx1ZVwiLCBcIkNvcHlcIiwgXCJCbGFua1wiLCBcIlJldHVybkludG9BcnJheVwiLCBcIlJldHVybkludG9PYmplY3RcIiwgXCJSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVwiLCBcIlB1c2hGaWVsZFwiLCBcIlB1c2hFbGVtZW50XCIsIFwiUHVzaFBhcmVudFwiLCBcIlBvcFwiLCBcIlB1c2hGaWVsZENvcHlcIiwgXCJQdXNoRmllbGRCbGFua1wiLCBcIlB1c2hFbGVtZW50Q29weVwiLCBcIlB1c2hFbGVtZW50QmxhbmtcIiwgXCJSZXR1cm5JbnRvT2JqZWN0UG9wXCIsIFwiUmV0dXJuSW50b09iamVjdFNhbWVLZXlQb3BcIiwgXCJSZXR1cm5JbnRvQXJyYXlQb3BcIiwgXCJPYmplY3RTZXRGaWVsZFZhbHVlXCIsIFwiT2JqZWN0Q29weUZpZWxkXCIsIFwiT2JqZWN0RGVsZXRlRmllbGRcIiwgXCJBcnJheUFwcGVuZFZhbHVlXCIsIFwiQXJyYXlBcHBlbmRTbGljZVwiLCBcIlN0cmluZ0FwcGVuZFN0cmluZ1wiLCBcIlN0cmluZ0FwcGVuZFNsaWNlXCJdO1xuY2xhc3MgUGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsLCByb290LCBwYXRjaCkge1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm1vZGVsXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInJvb3RcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicGF0Y2hcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpbnB1dFN0YWNrXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm91dHB1dFN0YWNrXCIpO1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIHRoaXMucGF0Y2ggPSBwYXRjaDtcbiAgICB0aGlzLmkgPSAwO1xuICAgIHRoaXMuaW5wdXRTdGFjayA9IFtdO1xuICAgIHRoaXMub3V0cHV0U3RhY2sgPSBbXTtcbiAgfVxuICByZWFkKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGNoW3RoaXMuaSsrXTtcbiAgfVxuICBwcm9jZXNzKCkge1xuICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHtcbiAgICAgIHZhbHVlOiB0aGlzLnJvb3RcbiAgICB9KTtcbiAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goe1xuICAgICAgdmFsdWU6IHRoaXMucm9vdFxuICAgIH0pO1xuICAgIGZvciAoOyB0aGlzLmkgPCB0aGlzLnBhdGNoLmxlbmd0aDspIHtcbiAgICAgIGxldCBvcGNvZGUgPSB0aGlzLnJlYWQoKTtcbiAgICAgIGxldCBvcCA9IE9QU1tvcGNvZGVdO1xuICAgICAgaWYgKCFvcCkgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGNvZGU6IFwiLmNvbmNhdChvcGNvZGUpKTtcbiAgICAgIGxldCBwcm9jZXNzb3IgPSBcInByb2Nlc3NcIi5jb25jYXQob3ApO1xuICAgICAgdGhpc1twcm9jZXNzb3JdLmFwcGx5KHRoaXMpO1xuICAgIH1cbiAgICBsZXQgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcbiAgfVxuICBpbnB1dEVudHJ5KCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0U3RhY2tbdGhpcy5pbnB1dFN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG4gIGlucHV0S2V5KGVudHJ5LCBpZHgpIHtcbiAgICBpZiAoIWVudHJ5LmtleXMpIHtcbiAgICAgIGVudHJ5LmtleXMgPSB0aGlzLm1vZGVsLm9iamVjdEdldEtleXMoZW50cnkudmFsdWUpLnNvcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5LmtleXNbaWR4XTtcbiAgfVxuICBvdXRwdXRFbnRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRTdGFja1t0aGlzLm91dHB1dFN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG4gIG91dHB1dEFycmF5KCkge1xuICAgIGxldCBlbnRyeSA9IHRoaXMub3V0cHV0RW50cnkoKTtcbiAgICBpZiAoIWVudHJ5LndyaXRlVmFsdWUpIHtcbiAgICAgIGVudHJ5LndyaXRlVmFsdWUgPSB0aGlzLm1vZGVsLmNvcHlBcnJheShlbnRyeS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlO1xuICB9XG4gIG91dHB1dE9iamVjdCgpIHtcbiAgICBsZXQgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgaWYgKCFlbnRyeS53cml0ZVZhbHVlKSB7XG4gICAgICBlbnRyeS53cml0ZVZhbHVlID0gdGhpcy5tb2RlbC5jb3B5T2JqZWN0KGVudHJ5LnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWU7XG4gIH1cbiAgb3V0cHV0U3RyaW5nKCkge1xuICAgIGxldCBlbnRyeSA9IHRoaXMub3V0cHV0RW50cnkoKTtcbiAgICBpZiAoIWVudHJ5LndyaXRlVmFsdWUpIHtcbiAgICAgIGVudHJ5LndyaXRlVmFsdWUgPSB0aGlzLm1vZGVsLmNvcHlTdHJpbmcoZW50cnkudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZTtcbiAgfVxuICBmaW5hbGl6ZU91dHB1dChlbnRyeSkge1xuICAgIGlmIChlbnRyeS53cml0ZVZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlbC5maW5hbGl6ZShlbnRyeS53cml0ZVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgIH1cbiAgfVxuICAvLyBQcm9jZXNzb3JzOlxuICBwcm9jZXNzVmFsdWUoKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5tb2RlbC53cmFwKHRoaXMucmVhZCgpKTtcbiAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goe1xuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfVxuICBwcm9jZXNzQ29weSgpIHtcbiAgICBsZXQgaW5wdXQgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goe1xuICAgICAgdmFsdWU6IGlucHV0LnZhbHVlXG4gICAgfSk7XG4gIH1cbiAgcHJvY2Vzc0JsYW5rKCkge1xuICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0pO1xuICB9XG4gIHByb2Nlc3NSZXR1cm5JbnRvQXJyYXkoKSB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5vdXRwdXRTdGFjay5wb3AoKTtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgbGV0IGFyciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcbiAgICB0aGlzLm1vZGVsLmFycmF5QXBwZW5kVmFsdWUoYXJyLCByZXN1bHQpO1xuICB9XG4gIHByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0KCkge1xuICAgIGxldCBrZXkgPSB0aGlzLnJlYWQoKTtcbiAgICBsZXQgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcbiAgICByZXN1bHQgPSB0aGlzLm1vZGVsLm1hcmtDaGFuZ2VkKHJlc3VsdCk7XG4gICAgbGV0IG9iaiA9IHRoaXMub3V0cHV0T2JqZWN0KCk7XG4gICAgdGhpcy5tb2RlbC5vYmplY3RTZXRGaWVsZChvYmosIGtleSwgcmVzdWx0KTtcbiAgfVxuICBwcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKSB7XG4gICAgbGV0IGlucHV0ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5vdXRwdXRTdGFjay5wb3AoKTtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgbGV0IG9iaiA9IHRoaXMub3V0cHV0T2JqZWN0KCk7XG4gICAgdGhpcy5tb2RlbC5vYmplY3RTZXRGaWVsZChvYmosIGlucHV0LmtleSwgcmVzdWx0KTtcbiAgfVxuICBwcm9jZXNzUHVzaEZpZWxkKCkge1xuICAgIGxldCBpZHggPSB0aGlzLnJlYWQoKTtcbiAgICBsZXQgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICBsZXQga2V5ID0gdGhpcy5pbnB1dEtleShlbnRyeSwgaWR4KTtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLm1vZGVsLm9iamVjdEdldEZpZWxkKGVudHJ5LnZhbHVlLCBrZXkpO1xuICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHtcbiAgICAgIHZhbHVlLFxuICAgICAga2V5XG4gICAgfSk7XG4gIH1cbiAgcHJvY2Vzc1B1c2hFbGVtZW50KCkge1xuICAgIGxldCBpZHggPSB0aGlzLnJlYWQoKTtcbiAgICBsZXQgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLm1vZGVsLmFycmF5R2V0RWxlbWVudChlbnRyeS52YWx1ZSwgaWR4KTtcbiAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7XG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9XG4gIHByb2Nlc3NQb3AoKSB7XG4gICAgdGhpcy5pbnB1dFN0YWNrLnBvcCgpO1xuICB9XG4gIHByb2Nlc3NQdXNoRmllbGRDb3B5KCkge1xuICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpO1xuICAgIHRoaXMucHJvY2Vzc0NvcHkoKTtcbiAgfVxuICBwcm9jZXNzUHVzaEZpZWxkQmxhbmsoKSB7XG4gICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XG4gICAgdGhpcy5wcm9jZXNzQmxhbmsoKTtcbiAgfVxuICBwcm9jZXNzUHVzaEVsZW1lbnRDb3B5KCkge1xuICAgIHRoaXMucHJvY2Vzc1B1c2hFbGVtZW50KCk7XG4gICAgdGhpcy5wcm9jZXNzQ29weSgpO1xuICB9XG4gIHByb2Nlc3NQdXNoRWxlbWVudEJsYW5rKCkge1xuICAgIHRoaXMucHJvY2Vzc1B1c2hFbGVtZW50KCk7XG4gICAgdGhpcy5wcm9jZXNzQmxhbmsoKTtcbiAgfVxuICBwcm9jZXNzUmV0dXJuSW50b09iamVjdFBvcCgpIHtcbiAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0KCk7XG4gICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gIH1cbiAgcHJvY2Vzc1JldHVybkludG9PYmplY3RTYW1lS2V5UG9wKCkge1xuICAgIHRoaXMucHJvY2Vzc1JldHVybkludG9PYmplY3RTYW1lS2V5KCk7XG4gICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gIH1cbiAgcHJvY2Vzc1JldHVybkludG9BcnJheVBvcCgpIHtcbiAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvQXJyYXkoKTtcbiAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgfVxuICBwcm9jZXNzT2JqZWN0U2V0RmllbGRWYWx1ZSgpIHtcbiAgICB0aGlzLnByb2Nlc3NWYWx1ZSgpO1xuICAgIHRoaXMucHJvY2Vzc1JldHVybkludG9PYmplY3QoKTtcbiAgfVxuICBwcm9jZXNzT2JqZWN0Q29weUZpZWxkKCkge1xuICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpO1xuICAgIHRoaXMucHJvY2Vzc0NvcHkoKTtcbiAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSgpO1xuICAgIHRoaXMucHJvY2Vzc1BvcCgpO1xuICB9XG4gIHByb2Nlc3NPYmplY3REZWxldGVGaWVsZCgpIHtcbiAgICBsZXQgaWR4ID0gdGhpcy5yZWFkKCk7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgbGV0IGtleSA9IHRoaXMuaW5wdXRLZXkoZW50cnksIGlkeCk7XG4gICAgbGV0IG9iaiA9IHRoaXMub3V0cHV0T2JqZWN0KCk7XG4gICAgdGhpcy5tb2RlbC5vYmplY3REZWxldGVGaWVsZChvYmosIGtleSk7XG4gIH1cbiAgcHJvY2Vzc0FycmF5QXBwZW5kVmFsdWUoKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5tb2RlbC53cmFwKHRoaXMucmVhZCgpKTtcbiAgICBsZXQgYXJyID0gdGhpcy5vdXRwdXRBcnJheSgpO1xuICAgIHRoaXMubW9kZWwuYXJyYXlBcHBlbmRWYWx1ZShhcnIsIHZhbHVlKTtcbiAgfVxuICBwcm9jZXNzQXJyYXlBcHBlbmRTbGljZSgpIHtcbiAgICBsZXQgbGVmdCA9IHRoaXMucmVhZCgpO1xuICAgIGxldCByaWdodCA9IHRoaXMucmVhZCgpO1xuICAgIGxldCBzdHIgPSB0aGlzLm91dHB1dEFycmF5KCk7XG4gICAgbGV0IHZhbCA9IHRoaXMuaW5wdXRFbnRyeSgpLnZhbHVlO1xuICAgIHRoaXMubW9kZWwuYXJyYXlBcHBlbmRTbGljZShzdHIsIHZhbCwgbGVmdCwgcmlnaHQpO1xuICB9XG4gIHByb2Nlc3NTdHJpbmdBcHBlbmRTdHJpbmcoKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5tb2RlbC53cmFwKHRoaXMucmVhZCgpKTtcbiAgICBsZXQgc3RyID0gdGhpcy5vdXRwdXRTdHJpbmcoKTtcbiAgICB0aGlzLm1vZGVsLnN0cmluZ0FwcGVuZFZhbHVlKHN0ciwgdmFsdWUpO1xuICB9XG4gIHByb2Nlc3NTdHJpbmdBcHBlbmRTbGljZSgpIHtcbiAgICBsZXQgbGVmdCA9IHRoaXMucmVhZCgpO1xuICAgIGxldCByaWdodCA9IHRoaXMucmVhZCgpO1xuICAgIGxldCBzdHIgPSB0aGlzLm91dHB1dFN0cmluZygpO1xuICAgIGxldCB2YWwgPSB0aGlzLmlucHV0RW50cnkoKS52YWx1ZTtcbiAgICB0aGlzLm1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHN0ciwgdmFsLCBsZWZ0LCByaWdodCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHV0ZjhjaGFyU2l6ZShjb2RlKSB7XG4gIGlmIChjb2RlID4+IDE2KSB7XG4gICAgcmV0dXJuIDQ7XG4gIH0gZWxzZSBpZiAoY29kZSA+PiAxMSkge1xuICAgIHJldHVybiAzO1xuICB9IGVsc2UgaWYgKGNvZGUgPj4gNykge1xuICAgIHJldHVybiAyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxO1xuICB9XG59XG5mdW5jdGlvbiB1dGY4c3RyaW5nU2l6ZShzdHIpIHtcbiAgbGV0IGIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjb2RlID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgIGxldCBzaXplID0gdXRmOGNoYXJTaXplKGNvZGUpO1xuICAgIGlmIChzaXplID09IDQpIGkrKztcbiAgICBiICs9IHNpemU7XG4gIH1cbiAgcmV0dXJuIGI7XG59XG5mdW5jdGlvbiB1dGY4cmVzb2x2ZUluZGV4KHN0ciwgaWR4KSB7XG4gIGxldCBzdGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgbGV0IGJ5dGVDb3VudCA9IHN0YXJ0O1xuICBsZXQgdWNzSWR4ID0gMDtcbiAgZm9yICh1Y3NJZHggPSBzdGFydDsgYnl0ZUNvdW50IDwgaWR4OyB1Y3NJZHgrKykge1xuICAgIGxldCBjb2RlID0gc3RyLmNvZGVQb2ludEF0KHVjc0lkeCk7XG4gICAgbGV0IHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XG4gICAgaWYgKHNpemUgPT09IDQpIHVjc0lkeCsrO1xuICAgIGJ5dGVDb3VudCArPSBzaXplO1xuICB9XG4gIHJldHVybiB1Y3NJZHg7XG59XG5mdW5jdGlvbiBjb21tb25QcmVmaXgoc3RyLCBzdHIyKSB7XG4gIGxldCBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBzdHIyLmxlbmd0aCk7XG4gIGxldCBiID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgbGV0IGFQb2ludCA9IHN0ci5jb2RlUG9pbnRBdChpKTtcbiAgICBsZXQgYlBvaW50ID0gc3RyMi5jb2RlUG9pbnRBdChpKTtcbiAgICBpZiAoYVBvaW50ICE9PSBiUG9pbnQpIHJldHVybiBiO1xuICAgIGxldCBzaXplID0gdXRmOGNoYXJTaXplKGFQb2ludCk7XG4gICAgYiArPSBzaXplO1xuICAgIGkgKz0gc2l6ZSA9PT0gNCA/IDIgOiAxO1xuICB9XG4gIHJldHVybiBiO1xufVxuZnVuY3Rpb24gY29tbW9uU3VmZml4KHN0ciwgc3RyMikge1xuICBsZXQgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICBsZXQgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgc3RyMi5sZW5ndGgpIC0gcHJlZml4O1xuICBsZXQgYiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGxldCBhUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoc3RyLmxlbmd0aCAtIDEgLSBpKTtcbiAgICBsZXQgYlBvaW50ID0gc3RyMi5jb2RlUG9pbnRBdChzdHIyLmxlbmd0aCAtIDEgLSBpKTtcbiAgICBpZiAoYVBvaW50ICE9PSBiUG9pbnQpIHJldHVybiBiO1xuICAgIGxldCBzaXplID0gdXRmOGNoYXJTaXplKGFQb2ludCk7XG4gICAgYiArPSBzaXplO1xuICAgIGkgKz0gc2l6ZSA9PT0gNCA/IDIgOiAxO1xuICB9XG4gIHJldHVybiBiO1xufVxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIEluY3JlbWVudGFsTW9kZWwge1xuICBjb25zdHJ1Y3RvcihtZXRhKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1ldGFcIik7XG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgfVxuICB3cmFwKGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwV2l0aE1ldGEoZGF0YSwgdGhpcy5tZXRhLCB0aGlzLm1ldGEpO1xuICB9XG4gIHdyYXBXaXRoTWV0YShkYXRhLCBzdGFydE1ldGEpIHtcbiAgICBsZXQgZW5kTWV0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5tZXRhO1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhLFxuICAgICAgc3RhcnRNZXRhLFxuICAgICAgZW5kTWV0YVxuICAgIH07XG4gIH1cbiAgYXNPYmplY3QodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLmNvbnRlbnQpIHtcbiAgICAgIGxldCBmaWVsZHMgPSB7fTtcbiAgICAgIGZvciAobGV0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUuZGF0YSkpIHtcbiAgICAgICAgZmllbGRzW2tleV0gPSB0aGlzLndyYXBXaXRoTWV0YSh2YWwsIHZhbHVlLnN0YXJ0TWV0YSk7XG4gICAgICB9XG4gICAgICB2YWx1ZS5jb250ZW50ID0ge1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBmaWVsZHNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5jb250ZW50O1xuICB9XG4gIGFzQXJyYXkodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLmNvbnRlbnQpIHtcbiAgICAgIGxldCBlbGVtZW50cyA9IHZhbHVlLmRhdGEubWFwKGl0ZW0gPT4gdGhpcy53cmFwV2l0aE1ldGEoaXRlbSwgdmFsdWUuc3RhcnRNZXRhKSk7XG4gICAgICBsZXQgbWV0YXMgPSBlbGVtZW50cy5tYXAoKCkgPT4gdGhpcy5tZXRhKTtcbiAgICAgIHZhbHVlLmNvbnRlbnQgPSB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIG1ldGFzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuY29udGVudDtcbiAgfVxuICBhc1N0cmluZyh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgbGV0IHN0ciA9IHZhbHVlLmRhdGE7XG4gICAgICBsZXQgcGFydCA9IHtcbiAgICAgICAgdmFsdWU6IHN0cixcbiAgICAgICAgdXRmOHNpemU6IHV0ZjhzdHJpbmdTaXplKHN0ciksXG4gICAgICAgIHVzZXM6IFtdLFxuICAgICAgICBzdGFydE1ldGE6IHZhbHVlLnN0YXJ0TWV0YSxcbiAgICAgICAgZW5kTWV0YTogdmFsdWUuZW5kTWV0YVxuICAgICAgfTtcbiAgICAgIHZhbHVlLmNvbnRlbnQgPSB0aGlzLnN0cmluZ0Zyb21QYXJ0cyhbcGFydF0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuY29udGVudDtcbiAgfVxuICBzdHJpbmdGcm9tUGFydHMocGFydHMpIHtcbiAgICBsZXQgc3RyID0ge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHBhcnRzXG4gICAgfTtcbiAgICBmb3IgKGxldCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICBwYXJ0LnVzZXMucHVzaChzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIG9iamVjdEdldEtleXModmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29udGVudCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlLmNvbnRlbnQuZmllbGRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlLmRhdGEpO1xuICAgIH1cbiAgfVxuICBvYmplY3RHZXRGaWVsZCh2YWx1ZSwga2V5KSB7XG4gICAgbGV0IG9iaiA9IHRoaXMuYXNPYmplY3QodmFsdWUpO1xuICAgIHJldHVybiBvYmouZmllbGRzW2tleV07XG4gIH1cbiAgYXJyYXlHZXRFbGVtZW50KHZhbHVlLCBpZHgpIHtcbiAgICBsZXQgYXJyID0gdGhpcy5hc0FycmF5KHZhbHVlKTtcbiAgICByZXR1cm4gYXJyLmVsZW1lbnRzW2lkeF07XG4gIH1cbiAgZmluYWxpemUoY29udGVudCkge1xuICAgIHRoaXMudXBkYXRlRW5kTWV0YShjb250ZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudCxcbiAgICAgIHN0YXJ0TWV0YTogdGhpcy5tZXRhLFxuICAgICAgZW5kTWV0YTogdGhpcy5tZXRhXG4gICAgfTtcbiAgfVxuICBtYXJrQ2hhbmdlZCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLndyYXAodW53cmFwKHZhbHVlKSk7XG4gIH1cbiAgdXBkYXRlRW5kTWV0YShjb250ZW50KSB7XG4gICAgaWYgKGNvbnRlbnQudHlwZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBmb3IgKGxldCBwYXJ0IG9mIGNvbnRlbnQucGFydHMpIHtcbiAgICAgICAgcGFydC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29udGVudC50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgZm9yIChsZXQgdmFsIG9mIGNvbnRlbnQuZWxlbWVudHMpIHtcbiAgICAgICAgICBpZiAodmFsLmNvbnRlbnQgJiYgdmFsLmVuZE1ldGEgIT09IHRoaXMubWV0YSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbmRNZXRhKHZhbC5jb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsLmVuZE1ldGEgPSB0aGlzLm1ldGE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IHZhbCBvZiBPYmplY3QudmFsdWVzKGNvbnRlbnQuZmllbGRzKSkge1xuICAgICAgICAgIGlmICh2YWwuY29udGVudCAmJiB2YWwuZW5kTWV0YSAhPT0gdGhpcy5tZXRhKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVuZE1ldGEodmFsLmNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWwuZW5kTWV0YSA9IHRoaXMubWV0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb3B5U3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBsZXQgb3RoZXIgPSB0aGlzLmFzU3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzLnN0cmluZ0Zyb21QYXJ0cyhvdGhlci5wYXJ0cy5zbGljZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgcGFydHM6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBjb3B5T2JqZWN0KHZhbHVlKSB7XG4gICAgbGV0IG9iaiA9IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBmaWVsZHM6IHt9XG4gICAgfTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGxldCBvdGhlciA9IHRoaXMuYXNPYmplY3QodmFsdWUpO1xuICAgICAgT2JqZWN0LmFzc2lnbihvYmouZmllbGRzLCBvdGhlci5maWVsZHMpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGNvcHlBcnJheSh2YWx1ZSkge1xuICAgIGxldCBhcnIgPSB2YWx1ZSA/IHRoaXMuYXNBcnJheSh2YWx1ZSkgOiBudWxsO1xuICAgIGxldCBlbGVtZW50cyA9IGFyciA/IGFyci5lbGVtZW50cyA6IFtdO1xuICAgIGxldCBtZXRhcyA9IGFyciA/IGFyci5tZXRhcyA6IFtdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICBlbGVtZW50cyxcbiAgICAgIG1ldGFzXG4gICAgfTtcbiAgfVxuICBvYmplY3RTZXRGaWVsZCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICB0YXJnZXQuZmllbGRzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICBvYmplY3REZWxldGVGaWVsZCh0YXJnZXQsIGtleSkge1xuICAgIGRlbGV0ZSB0YXJnZXQuZmllbGRzW2tleV07XG4gIH1cbiAgYXJyYXlBcHBlbmRWYWx1ZSh0YXJnZXQsIHZhbHVlKSB7XG4gICAgdGFyZ2V0LmVsZW1lbnRzLnB1c2godmFsdWUpO1xuICAgIHRhcmdldC5tZXRhcy5wdXNoKHRoaXMubWV0YSk7XG4gIH1cbiAgYXJyYXlBcHBlbmRTbGljZSh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICBsZXQgYXJyID0gdGhpcy5hc0FycmF5KHNvdXJjZSk7XG4gICAgbGV0IHNhbWVQb3NpdGlvbiA9IGFyci5lbGVtZW50cy5sZW5ndGggPT09IGxlZnQ7XG4gICAgdGFyZ2V0LmVsZW1lbnRzLnB1c2goLi4uYXJyLmVsZW1lbnRzLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XG4gICAgaWYgKHNhbWVQb3NpdGlvbikge1xuICAgICAgdGFyZ2V0Lm1ldGFzLnB1c2goLi4uYXJyLm1ldGFzLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSBsZWZ0OyBpIDwgcmlnaHQ7IGkrKykge1xuICAgICAgICB0YXJnZXQubWV0YXMucHVzaCh0aGlzLm1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdHJpbmdBcHBlbmRWYWx1ZSh0YXJnZXQsIHZhbHVlKSB7XG4gICAgbGV0IHN0ciA9IHRoaXMuYXNTdHJpbmcodmFsdWUpO1xuICAgIGZvciAobGV0IHBhcnQgb2Ygc3RyLnBhcnRzKSB7XG4gICAgICB0aGlzLnN0cmluZ0FwcGVuZFBhcnQodGFyZ2V0LCBwYXJ0KTtcbiAgICB9XG4gIH1cbiAgc3RyaW5nQXBwZW5kUGFydCh0YXJnZXQsIHBhcnQpIHtcbiAgICB0YXJnZXQucGFydHMucHVzaChwYXJ0KTtcbiAgICBwYXJ0LnVzZXMucHVzaCh0YXJnZXQpO1xuICB9XG4gIHJlc29sdmVTdHJpbmdQYXJ0KHN0ciwgZnJvbSwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIGZyb207XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCBzdHIucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBwYXJ0ID0gc3RyLnBhcnRzW2ldO1xuICAgICAgaWYgKGxlbiA9PT0gcGFydC51dGY4c2l6ZSkge1xuICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAobGVuIDwgcGFydC51dGY4c2l6ZSkge1xuICAgICAgICB0aGlzLnNwbGl0U3RyaW5nKHBhcnQsIGxlbik7XG4gICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgIH1cbiAgICAgIGxlbiAtPSBwYXJ0LnV0ZjhzaXplO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzcGxpdHRpbmcgc3RyaW5nIG91dCBvZiBib3VuZHNcIik7XG4gIH1cbiAgc3BsaXRTdHJpbmcocGFydCwgaWR4KSB7XG4gICAgbGV0IGxlZnRWYWx1ZTtcbiAgICBsZXQgcmlnaHRWYWx1ZTtcbiAgICBsZXQgbGVmdFNpemUgPSBpZHg7XG4gICAgbGV0IHJpZ2h0U2l6ZSA9IHBhcnQudXRmOHNpemUgLSBsZWZ0U2l6ZTtcbiAgICBpZiAocGFydC51dGY4c2l6ZSAhPT0gcGFydC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgIGxldCBieXRlQ291bnQgPSAwO1xuICAgICAgZm9yIChpZHggPSAwOyBieXRlQ291bnQgPCBsZWZ0U2l6ZTsgaWR4KyspIHtcbiAgICAgICAgbGV0IGNvZGUgPSBwYXJ0LnZhbHVlLmNvZGVQb2ludEF0KGlkeCk7XG4gICAgICAgIGxldCBzaXplID0gdXRmOGNoYXJTaXplKGNvZGUpO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gNCkgaWR4Kys7XG4gICAgICAgIGJ5dGVDb3VudCArPSBzaXplO1xuICAgICAgfVxuICAgIH1cbiAgICBsZWZ0VmFsdWUgPSBwYXJ0LnZhbHVlLnNsaWNlKDAsIGlkeCk7XG4gICAgcmlnaHRWYWx1ZSA9IHBhcnQudmFsdWUuc2xpY2UoaWR4KTtcbiAgICBsZXQgbmV3UGFydCA9IHtcbiAgICAgIHZhbHVlOiByaWdodFZhbHVlLFxuICAgICAgdXRmOHNpemU6IHJpZ2h0U2l6ZSxcbiAgICAgIHVzZXM6IHBhcnQudXNlcy5zbGljZSgpLFxuICAgICAgc3RhcnRNZXRhOiBwYXJ0LnN0YXJ0TWV0YSxcbiAgICAgIGVuZE1ldGE6IHBhcnQuZW5kTWV0YVxuICAgIH07XG4gICAgcGFydC52YWx1ZSA9IGxlZnRWYWx1ZTtcbiAgICBwYXJ0LnV0ZjhzaXplID0gbGVmdFNpemU7XG4gICAgZm9yIChsZXQgdXNlIG9mIHBhcnQudXNlcykge1xuICAgICAgbGV0IG5keCA9IHVzZS5wYXJ0cy5pbmRleE9mKHBhcnQpO1xuICAgICAgaWYgKG5keCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihcImJ1ZzogbWlzbWF0Y2ggYmV0d2VlbiBzdHJpbmcgcGFydHMgYW5kIHVzZS5cIik7XG4gICAgICB1c2UucGFydHMuc3BsaWNlKG5keCArIDEsIDAsIG5ld1BhcnQpO1xuICAgIH1cbiAgfVxuICBzdHJpbmdBcHBlbmRTbGljZSh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICBsZXQgc3RyID0gdGhpcy5hc1N0cmluZyhzb3VyY2UpO1xuICAgIGxldCBmaXJzdFBhcnQgPSB0aGlzLnJlc29sdmVTdHJpbmdQYXJ0KHN0ciwgMCwgbGVmdCk7XG4gICAgbGV0IGxhc3RQYXJ0ID0gdGhpcy5yZXNvbHZlU3RyaW5nUGFydChzdHIsIGZpcnN0UGFydCwgcmlnaHQgLSBsZWZ0KTtcbiAgICBmb3IgKGxldCBpID0gZmlyc3RQYXJ0OyBpIDwgbGFzdFBhcnQ7IGkrKykge1xuICAgICAgbGV0IHBhcnQgPSBzdHIucGFydHNbaV07XG4gICAgICB0aGlzLnN0cmluZ0FwcGVuZFBhcnQodGFyZ2V0LCBwYXJ0KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHdyYXAoZGF0YSwgbWV0YSkge1xuICByZXR1cm4ge1xuICAgIGRhdGEsXG4gICAgc3RhcnRNZXRhOiBtZXRhLFxuICAgIGVuZE1ldGE6IG1ldGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHVud3JhcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlLmRhdGEgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB2YWx1ZS5kYXRhO1xuICBsZXQgcmVzdWx0O1xuICBsZXQgY29udGVudCA9IHZhbHVlLmNvbnRlbnQ7XG4gIHN3aXRjaCAoY29udGVudC50eXBlKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmVzdWx0ID0gY29udGVudC5wYXJ0cy5tYXAocGFydCA9PiBwYXJ0LnZhbHVlKS5qb2luKFwiXCIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICByZXN1bHQgPSBjb250ZW50LmVsZW1lbnRzLm1hcCh2YWwgPT4gdW53cmFwKHZhbCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAge1xuICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhjb250ZW50LmZpZWxkcykpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHVud3JhcCh2YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cbiAgdmFsdWUuZGF0YSA9IHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlLmNvbnRlbnQpIHJldHVybiB2YWx1ZS5jb250ZW50LnR5cGU7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKSByZXR1cm4gXCJhcnJheVwiO1xuICBpZiAodmFsdWUuZGF0YSA9PT0gbnVsbCkgcmV0dXJuIFwibnVsbFwiO1xuICByZXR1cm4gdHlwZW9mIHZhbHVlLmRhdGE7XG59XG5mdW5jdGlvbiByZWJhc2VWYWx1ZShsZWZ0LCByaWdodCkge1xuICBsZXQgbGVmdFR5cGUgPSBnZXRUeXBlKGxlZnQpO1xuICBsZXQgcmlnaHRUeXBlID0gZ2V0VHlwZShyaWdodCk7XG4gIGlmIChsZWZ0VHlwZSAhPT0gcmlnaHRUeXBlKSByZXR1cm4gcmlnaHQ7XG4gIGxldCBsZWZ0TW9kZWwgPSBuZXcgSW5jcmVtZW50YWxNb2RlbChsZWZ0LmVuZE1ldGEpO1xuICBsZXQgcmlnaHRNb2RlbCA9IG5ldyBJbmNyZW1lbnRhbE1vZGVsKHJpZ2h0LmVuZE1ldGEpO1xuICBzd2l0Y2ggKGxlZnRUeXBlKSB7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAge1xuICAgICAgICBsZXQgbGVmdE9iaiA9IGxlZnRNb2RlbC5hc09iamVjdChsZWZ0KTtcbiAgICAgICAgbGV0IHJpZ2h0T2JqID0gcmlnaHRNb2RlbC5hc09iamVjdChyaWdodCk7XG4gICAgICAgIGxldCBpZGVudGljYWxGaWVsZENvdW50ID0gMDtcbiAgICAgICAgbGV0IGxlZnRGaWVsZENvdW50ID0gT2JqZWN0LmtleXMobGVmdE9iai5maWVsZHMpLmxlbmd0aDtcbiAgICAgICAgbGV0IHJpZ2h0RmllbGRDb3VudCA9IE9iamVjdC5rZXlzKHJpZ2h0T2JqLmZpZWxkcykubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBba2V5LCByaWdodFZhbF0gb2YgT2JqZWN0LmVudHJpZXMocmlnaHRPYmouZmllbGRzKSkge1xuICAgICAgICAgIGxldCBsZWZ0VmFsID0gbGVmdE9iai5maWVsZHNba2V5XTtcbiAgICAgICAgICBpZiAobGVmdFZhbCkge1xuICAgICAgICAgICAgcmlnaHRPYmouZmllbGRzW2tleV0gPSByZWJhc2VWYWx1ZShsZWZ0VmFsLCByaWdodFZhbCk7XG4gICAgICAgICAgICBpZiAocmlnaHRPYmouZmllbGRzW2tleV0gPT09IGxlZnRWYWwpIHtcbiAgICAgICAgICAgICAgaWRlbnRpY2FsRmllbGRDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNJZGVudGljYWwgPSBsZWZ0RmllbGRDb3VudCA9PT0gcmlnaHRGaWVsZENvdW50ICYmIGxlZnRGaWVsZENvdW50ID09PSBpZGVudGljYWxGaWVsZENvdW50O1xuICAgICAgICByZXR1cm4gaXNJZGVudGljYWwgPyBsZWZ0IDogcmlnaHQ7XG4gICAgICB9XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICB7XG4gICAgICAgIGxldCBsZWZ0QXJyID0gbGVmdE1vZGVsLmFzQXJyYXkobGVmdCk7XG4gICAgICAgIGxldCByaWdodEFyciA9IHJpZ2h0TW9kZWwuYXNBcnJheShyaWdodCk7XG4gICAgICAgIGlmIChsZWZ0QXJyLmVsZW1lbnRzLmxlbmd0aCAhPT0gcmlnaHRBcnIuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bVJlYmFzZWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJpZ2h0QXJyLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmlnaHRBcnIuZWxlbWVudHNbaV0gPSByZWJhc2VWYWx1ZShsZWZ0QXJyLmVsZW1lbnRzW2ldLCByaWdodEFyci5lbGVtZW50c1tpXSk7XG4gICAgICAgICAgaWYgKHJpZ2h0QXJyLmVsZW1lbnRzW2ldICE9PSBsZWZ0QXJyLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgICBudW1SZWJhc2VkKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW1SZWJhc2VkID09PSAwID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgfVxuICAgIGNhc2UgXCJudWxsXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICB7XG4gICAgICAgIGlmICh1bndyYXAobGVmdCkgPT09IHVud3JhcChyaWdodCkpIHJldHVybiBsZWZ0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICB7XG4gICAgICAgIGxldCBsZWZ0UmF3ID0gdW53cmFwKGxlZnQpO1xuICAgICAgICBsZXQgcmlnaHRSYXcgPSB1bndyYXAocmlnaHQpO1xuICAgICAgICBpZiAobGVmdFJhdyA9PT0gcmlnaHRSYXcpIHJldHVybiBsZWZ0O1xuICAgICAgICBsZXQgcmVzdWx0ID0gcmlnaHRNb2RlbC5jb3B5U3RyaW5nKG51bGwpO1xuICAgICAgICBsZXQgcHJlZml4ID0gY29tbW9uUHJlZml4KGxlZnRSYXcsIHJpZ2h0UmF3KTtcbiAgICAgICAgbGV0IHN1ZmZpeCA9IGNvbW1vblN1ZmZpeChsZWZ0UmF3LCByaWdodFJhdywgcHJlZml4KTtcbiAgICAgICAgbGV0IHJpZ2h0TGVuID0gdXRmOHN0cmluZ1NpemUocmlnaHRSYXcpO1xuICAgICAgICBsZXQgbGVmdExlbiA9IHV0ZjhzdHJpbmdTaXplKGxlZnRSYXcpO1xuICAgICAgICBpZiAoMCA8IHByZWZpeCkge1xuICAgICAgICAgIHJpZ2h0TW9kZWwuc3RyaW5nQXBwZW5kU2xpY2UocmVzdWx0LCBsZWZ0LCAwLCBwcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmaXggPCByaWdodExlbiAtIHN1ZmZpeCkge1xuICAgICAgICAgIHJpZ2h0TW9kZWwuc3RyaW5nQXBwZW5kU2xpY2UocmVzdWx0LCByaWdodCwgcHJlZml4LCByaWdodExlbiAtIHN1ZmZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnRMZW4gLSBzdWZmaXggPCBsZWZ0TGVuKSB7XG4gICAgICAgICAgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIGxlZnQsIGxlZnRMZW4gLSBzdWZmaXgsIGxlZnRMZW4pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWx1ZSA9IHJpZ2h0TW9kZWwuZmluYWxpemUocmVzdWx0KTtcbiAgICAgICAgaWYgKHVud3JhcCh2YWx1ZSkgIT09IHJpZ2h0UmF3KSB0aHJvdyBuZXcgRXJyb3IoXCJpbmNvcnJlY3Qgc3RyaW5nIHJlYmFzZVwiKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICB9XG4gIHJldHVybiByaWdodDtcbn1cbmZ1bmN0aW9uIGFwcGx5UGF0Y2gkMShsZWZ0LCBwYXRjaCwgc3RhcnRNZXRhKSB7XG4gIGxldCBtb2RlbCA9IG5ldyBJbmNyZW1lbnRhbE1vZGVsKHN0YXJ0TWV0YSk7XG4gIGxldCBwYXRjaGVyID0gbmV3IFBhdGNoZXIobW9kZWwsIGxlZnQsIHBhdGNoKTtcbiAgcmV0dXJuIHBhdGNoZXIucHJvY2VzcygpO1xufVxudmFyIGluY3JlbWVudGFsUGF0Y2hlciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhcHBseVBhdGNoOiBhcHBseVBhdGNoJDEsXG4gIGdldFR5cGU6IGdldFR5cGUsXG4gIHJlYmFzZVZhbHVlOiByZWJhc2VWYWx1ZSxcbiAgdW53cmFwOiB1bndyYXAsXG4gIHdyYXA6IHdyYXBcbn0pO1xuY2xhc3MgU2ltcGxlTW9kZWwge1xuICB3cmFwKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBmaW5hbGl6ZShiKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYi5kYXRhO1xuICAgIH1cbiAgfVxuICBtYXJrQ2hhbmdlZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBvYmplY3RHZXRLZXlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgfVxuICBvYmplY3RHZXRGaWVsZCh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlW2tleV07XG4gIH1cbiAgYXJyYXlHZXRFbGVtZW50KHZhbHVlLCBpZHgpIHtcbiAgICByZXR1cm4gdmFsdWVbaWR4XTtcbiAgfVxuICBjb3B5T2JqZWN0KHZhbHVlKSB7XG4gICAgbGV0IHJlcyA9IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICByZXMuZGF0YVtrZXldID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGNvcHlBcnJheSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xuICB9XG4gIGNvcHlTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIGRhdGE6IHZhbHVlID09PSBudWxsID8gXCJcIiA6IHZhbHVlXG4gICAgfTtcbiAgfVxuICBvYmplY3RTZXRGaWVsZCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICB0YXJnZXQuZGF0YVtrZXldID0gdmFsdWU7XG4gIH1cbiAgb2JqZWN0RGVsZXRlRmllbGQodGFyZ2V0LCBrZXkpIHtcbiAgICBkZWxldGUgdGFyZ2V0LmRhdGFba2V5XTtcbiAgfVxuICBhcnJheUFwcGVuZFZhbHVlKHRhcmdldCwgdmFsdWUpIHtcbiAgICB0YXJnZXQucHVzaCh2YWx1ZSk7XG4gIH1cbiAgYXJyYXlBcHBlbmRTbGljZSh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICB0YXJnZXQucHVzaCguLi5zb3VyY2Uuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgfVxuICBzdHJpbmdBcHBlbmRTbGljZSh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBzb3VyY2VTdHJpbmcgPSBzb3VyY2U7XG4gICAgY29uc3QgbGVmdFBvcyA9IHV0ZjhyZXNvbHZlSW5kZXgoc291cmNlU3RyaW5nLCBsZWZ0KTtcbiAgICBjb25zdCByaWdodFBvcyA9IHV0ZjhyZXNvbHZlSW5kZXgoc291cmNlU3RyaW5nLCByaWdodCwgbGVmdFBvcyk7XG4gICAgdGFyZ2V0LmRhdGEgKz0gc291cmNlU3RyaW5nLnNsaWNlKGxlZnRQb3MsIHJpZ2h0UG9zKTtcbiAgfVxuICBzdHJpbmdBcHBlbmRWYWx1ZSh0YXJnZXQsIHZhbHVlKSB7XG4gICAgdGFyZ2V0LmRhdGEgKz0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGx5UGF0Y2gobGVmdCwgcGF0Y2gpIHtcbiAgbGV0IHJvb3QgPSBsZWZ0O1xuICBsZXQgcGF0Y2hlciA9IG5ldyBQYXRjaGVyKG5ldyBTaW1wbGVNb2RlbCgpLCByb290LCBwYXRjaCk7XG4gIHJldHVybiBwYXRjaGVyLnByb2Nlc3MoKTtcbn1cbmV4cG9ydHMuYXBwbHlQYXRjaCA9IGFwcGx5UGF0Y2g7XG5leHBvcnRzLmluY3JlbWVudGFsID0gaW5jcmVtZW50YWxQYXRjaGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mendoza/dist/index.cjs\n");

/***/ })

};
;