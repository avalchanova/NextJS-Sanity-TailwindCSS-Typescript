"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/groq-js";
exports.ids = ["vendor-chunks/groq-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/groq-js/dist/1.js":
/*!****************************************!*\
  !*** ./node_modules/groq-js/dist/1.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar __defProp$5 = Object.defineProperty;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$5 = (obj, key, value) => {\n  __defNormalProp$5(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n  const re = [];\n  for (const part of pattern.split(\".\")) {\n    if (part === \"*\") {\n      re.push(\"[^.]+\");\n    } else if (part === \"**\") {\n      re.push(\".*\");\n    } else {\n      re.push(escapeRegExp(part));\n    }\n  }\n  return new RegExp(\"^\".concat(re.join(\".\"), \"$\"));\n}\nclass Path {\n  constructor(pattern) {\n    __publicField$5(this, \"pattern\");\n    __publicField$5(this, \"patternRe\");\n    this.pattern = pattern;\n    this.patternRe = pathRegExp(pattern);\n  }\n  matches(str) {\n    return this.patternRe.test(str);\n  }\n  toJSON() {\n    return this.pattern;\n  }\n}\nvar __defProp$4 = Object.defineProperty;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$4 = (obj, key, value) => {\n  __defNormalProp$4(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass StreamValue {\n  constructor(generator) {\n    __publicField$4(this, \"type\", \"stream\");\n    __publicField$4(this, \"generator\");\n    __publicField$4(this, \"ticker\");\n    __publicField$4(this, \"isDone\");\n    __publicField$4(this, \"data\");\n    this.generator = generator;\n    this.ticker = null;\n    this.isDone = false;\n    this.data = [];\n  }\n  // eslint-disable-next-line class-methods-use-this\n  isArray() {\n    return true;\n  }\n  async get() {\n    const result = [];\n    for await (const value of this) {\n      result.push(await value.get());\n    }\n    return result;\n  }\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    while (true) {\n      for (; i < this.data.length; i++) {\n        yield this.data[i];\n      }\n      if (this.isDone) {\n        return;\n      }\n      await this._nextTick();\n    }\n  }\n  _nextTick() {\n    if (this.ticker) {\n      return this.ticker;\n    }\n    let currentResolver;\n    const setupTicker = () => {\n      this.ticker = new Promise(resolve => {\n        currentResolver = resolve;\n      });\n    };\n    const tick = () => {\n      currentResolver();\n      setupTicker();\n    };\n    const fetch = async () => {\n      for await (const value of this.generator()) {\n        this.data.push(value);\n        tick();\n      }\n      this.isDone = true;\n      tick();\n    };\n    setupTicker();\n    fetch();\n    return this.ticker;\n  }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n  if (RFC3339_REGEX.test(str)) {\n    return new Date(str);\n  }\n  return null;\n}\nfunction formatRFC3339(d) {\n  const year = addLeadingZero(d.getUTCFullYear(), 4);\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2);\n  const day = addLeadingZero(d.getUTCDate(), 2);\n  const hour = addLeadingZero(d.getUTCHours(), 2);\n  const minute = addLeadingZero(d.getUTCMinutes(), 2);\n  const second = addLeadingZero(d.getUTCSeconds(), 2);\n  let fractionalSecond = \"\";\n  const millis = d.getMilliseconds();\n  if (millis != 0) {\n    fractionalSecond = \".\".concat(addLeadingZero(millis, 3));\n  }\n  return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute, \":\").concat(second).concat(fractionalSecond, \"Z\");\n}\nfunction addLeadingZero(num, targetLength) {\n  let str = num.toString();\n  while (str.length < targetLength) {\n    str = \"0\".concat(str);\n  }\n  return str;\n}\nvar __defProp$3 = Object.defineProperty;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$3 = (obj, key, value) => {\n  __defNormalProp$3(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass StaticValue {\n  constructor(data, type) {\n    __publicField$3(this, \"data\");\n    __publicField$3(this, \"type\");\n    this.data = data;\n    this.type = type;\n  }\n  isArray() {\n    return this.type === \"array\";\n  }\n  // eslint-disable-next-line require-await\n  async get() {\n    return this.data;\n  }\n  [Symbol.asyncIterator]() {\n    if (Array.isArray(this.data)) {\n      return function* (data) {\n        for (const element of data) {\n          yield fromJS(element);\n        }\n      }(this.data);\n    }\n    throw new Error(\"Cannot iterate over: \".concat(this.type));\n  }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\");\nconst TRUE_VALUE = new StaticValue(true, \"boolean\");\nconst FALSE_VALUE = new StaticValue(false, \"boolean\");\nclass DateTime {\n  constructor(date) {\n    __publicField$3(this, \"date\");\n    this.date = date;\n  }\n  static parseToValue(str) {\n    const date = parseRFC3339(str);\n    if (date) {\n      return new StaticValue(new DateTime(date), \"datetime\");\n    }\n    return NULL_VALUE;\n  }\n  equals(other) {\n    return this.date.getTime() == other.date.getTime();\n  }\n  add(secs) {\n    const copy = new Date(this.date.getTime());\n    copy.setTime(copy.getTime() + secs * 1e3);\n    return new DateTime(copy);\n  }\n  difference(other) {\n    return (this.date.getTime() - other.date.getTime()) / 1e3;\n  }\n  compareTo(other) {\n    return this.date.getTime() - other.date.getTime();\n  }\n  toString() {\n    return formatRFC3339(this.date);\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction fromNumber(num) {\n  if (Number.isFinite(num)) {\n    return new StaticValue(num, \"number\");\n  }\n  return NULL_VALUE;\n}\nfunction fromString(str) {\n  return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n  return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path) {\n  return new StaticValue(path, \"path\");\n}\nfunction isIterator(obj) {\n  return obj && typeof obj.next === \"function\";\n}\nfunction fromJS(val) {\n  if (isIterator(val)) {\n    return new StreamValue(async function* () {\n      for await (const value of val) {\n        yield fromJS(value);\n      }\n    });\n  } else if (val === null || val === void 0) {\n    return NULL_VALUE;\n  }\n  return new StaticValue(val, getType(val));\n}\nfunction getType(data) {\n  if (data === null || typeof data === \"undefined\") {\n    return \"null\";\n  }\n  if (Array.isArray(data)) {\n    return \"array\";\n  }\n  if (data instanceof Path) {\n    return \"path\";\n  }\n  if (data instanceof DateTime) {\n    return \"datetime\";\n  }\n  return typeof data;\n}\nfunction isEqual(a, b) {\n  if (a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\") {\n    return a.data === b.data;\n  }\n  if (a.type === \"datetime\" && b.type === \"datetime\") {\n    return a.data.equals(b.data);\n  }\n  return false;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nconst MAX_TERM_LENGTH = 1024;\nfunction matchText(tokens, patterns) {\n  if (tokens.length === 0 || patterns.length === 0) {\n    return false;\n  }\n  return patterns.every(pattern => pattern(tokens));\n}\nfunction matchTokenize(text) {\n  return text.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n  const termsRe = matchPatternRegex(text);\n  return termsRe.map(re => tokens => tokens.some(token => re.test(token)));\n}\nfunction matchPatternRegex(text) {\n  const terms = text.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || [];\n  return terms.map(term => new RegExp(\"^\".concat(term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, \".*\"), \"$\"), \"i\"));\n}\nasync function gatherText(value, cb) {\n  if (value.type === \"string\") {\n    cb(value.data);\n    return true;\n  }\n  if (value.isArray()) {\n    let success = true;\n    for await (const part of value) {\n      if (part.type === \"string\") {\n        cb(part.data);\n      } else {\n        success = false;\n      }\n    }\n    return success;\n  }\n  return false;\n}\nconst TYPE_ORDER = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4\n};\nfunction partialCompare(a, b) {\n  const aType = getType(a);\n  const bType = getType(b);\n  if (aType !== bType) {\n    return null;\n  }\n  switch (aType) {\n    case \"number\":\n    case \"boolean\":\n      return a - b;\n    case \"string\":\n      if (a < b) return -1;\n      if (a > b) return 1;\n      return 0;\n    case \"datetime\":\n      return a.compareTo(b);\n    default:\n      return null;\n  }\n}\nfunction totalCompare(a, b) {\n  const aType = getType(a);\n  const bType = getType(b);\n  const aTypeOrder = TYPE_ORDER[aType] || 100;\n  const bTypeOrder = TYPE_ORDER[bType] || 100;\n  if (aTypeOrder !== bTypeOrder) {\n    return aTypeOrder - bTypeOrder;\n  }\n  let result = partialCompare(a, b);\n  if (result === null) {\n    result = 0;\n  }\n  return result;\n}\nconst operators = {\n  \"==\": function eq(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"!=\": function neq(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n  },\n  \">\": function gt(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \">=\": function gte(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<\": function lt(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<=\": function lte(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  // eslint-disable-next-line func-name-matching\n  in: async function inop(left, right) {\n    if (right.type === \"path\") {\n      if (left.type !== \"string\") {\n        return NULL_VALUE;\n      }\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n    }\n    if (right.isArray()) {\n      for await (const b of right) {\n        if (isEqual(left, b)) {\n          return TRUE_VALUE;\n        }\n      }\n      return FALSE_VALUE;\n    }\n    return NULL_VALUE;\n  },\n  match: async function match(left, right) {\n    let tokens = [];\n    let patterns = [];\n    await gatherText(left, part => {\n      tokens = tokens.concat(matchTokenize(part));\n    });\n    const didSucceed = await gatherText(right, part => {\n      patterns = patterns.concat(matchAnalyzePattern(part));\n    });\n    if (!didSucceed) {\n      return FALSE_VALUE;\n    }\n    const matched = matchText(tokens, patterns);\n    return matched ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"+\": function plus(left, right) {\n    if (left.type === \"datetime\" && right.type === \"number\") {\n      return fromDateTime(left.data.add(right.data));\n    }\n    if (left.type === \"number\" && right.type === \"number\") {\n      return fromNumber(left.data + right.data);\n    }\n    if (left.type === \"string\" && right.type === \"string\") {\n      return fromString(left.data + right.data);\n    }\n    if (left.type === \"object\" && right.type === \"object\") {\n      return fromJS({\n        ...left.data,\n        ...right.data\n      });\n    }\n    if (left.type === \"array\" && right.type === \"array\") {\n      return fromJS(left.data.concat(right.data));\n    }\n    if (left.isArray() && right.isArray()) {\n      return new StreamValue(async function* () {\n        for await (const val of left) {\n          yield val;\n        }\n        for await (const val of right) {\n          yield val;\n        }\n      });\n    }\n    return NULL_VALUE;\n  },\n  \"-\": function minus(left, right) {\n    if (left.type === \"datetime\" && right.type === \"number\") {\n      return fromDateTime(left.data.add(-right.data));\n    }\n    if (left.type === \"datetime\" && right.type === \"datetime\") {\n      return fromNumber(left.data.difference(right.data));\n    }\n    if (left.type === \"number\" && right.type === \"number\") {\n      return fromNumber(left.data - right.data);\n    }\n    return NULL_VALUE;\n  },\n  \"*\": numericOperator((a, b) => a * b),\n  \"/\": numericOperator((a, b) => a / b),\n  \"%\": numericOperator((a, b) => a % b),\n  \"**\": numericOperator((a, b) => Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n  return function (left, right) {\n    if (left.type === \"number\" && right.type === \"number\") {\n      const result = impl(left.data, right.data);\n      return fromNumber(result);\n    }\n    return NULL_VALUE;\n  };\n}\nvar __defProp$2 = Object.defineProperty;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$2 = (obj, key, value) => {\n  __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass Scope {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(params, source, value, context, parent) {\n    __publicField$2(this, \"params\");\n    __publicField$2(this, \"source\");\n    __publicField$2(this, \"value\");\n    __publicField$2(this, \"parent\");\n    __publicField$2(this, \"context\");\n    __publicField$2(this, \"isHidden\", false);\n    this.params = params;\n    this.source = source;\n    this.value = value;\n    this.context = context;\n    this.parent = parent;\n  }\n  createNested(value) {\n    if (this.isHidden) {\n      return new Scope(this.params, this.source, value, this.context, this.parent);\n    }\n    return new Scope(this.params, this.source, value, this.context, this);\n  }\n  createHidden(value) {\n    const result = this.createNested(value);\n    result.isHidden = true;\n    return result;\n  }\n}\nfunction evaluate(node, scope) {\n  let execute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : evaluate;\n  const func = EXECUTORS[node.type];\n  return func(node, scope, execute);\n}\nfunction promiselessApply(value, cb) {\n  if (\"then\" in value) {\n    return value.then(cb);\n  }\n  return cb(value);\n}\nconst EXECUTORS = {\n  This(_, scope) {\n    return scope.value;\n  },\n  Selector() {\n    throw new Error(\"Selectors can not be evaluated\");\n  },\n  Everything(_, scope) {\n    return scope.source;\n  },\n  Parameter(_ref, scope) {\n    let {\n      name\n    } = _ref;\n    return fromJS(scope.params[name]);\n  },\n  Context(_ref2, scope) {\n    let {\n      key\n    } = _ref2;\n    if (key === \"before\" || key === \"after\") {\n      const value = scope.context[key];\n      return value || NULL_VALUE;\n    }\n    throw new Error(\"unknown context key: \".concat(key));\n  },\n  Parent(_ref3, scope) {\n    let {\n      n\n    } = _ref3;\n    let current = scope;\n    for (let i = 0; i < n; i++) {\n      if (!current.parent) {\n        return NULL_VALUE;\n      }\n      current = current.parent;\n    }\n    return current.value;\n  },\n  OpCall(_ref4, scope, execute) {\n    let {\n      op,\n      left,\n      right\n    } = _ref4;\n    const func = operators[op];\n    if (!func) {\n      throw new Error(\"Unknown operator: \".concat(op));\n    }\n    const leftValue = execute(left, scope);\n    const rightValue = execute(right, scope);\n    if (\"then\" in leftValue || \"then\" in rightValue) {\n      return (async () => func(await leftValue, await rightValue))();\n    }\n    return func(leftValue, rightValue);\n  },\n  async Select(_ref5, scope, execute) {\n    let {\n      alternatives,\n      fallback\n    } = _ref5;\n    for (const alt of alternatives) {\n      const altCond = await execute(alt.condition, scope);\n      if (altCond.type === \"boolean\" && altCond.data === true) {\n        return execute(alt.value, scope);\n      }\n    }\n    if (fallback) {\n      return execute(fallback, scope);\n    }\n    return NULL_VALUE;\n  },\n  async InRange(_ref6, scope, execute) {\n    let {\n      base,\n      left,\n      right,\n      isInclusive\n    } = _ref6;\n    const value = await execute(base, scope);\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    const leftCmp = partialCompare(await value.get(), await leftValue.get());\n    if (leftCmp === null) {\n      return NULL_VALUE;\n    }\n    const rightCmp = partialCompare(await value.get(), await rightValue.get());\n    if (rightCmp === null) {\n      return NULL_VALUE;\n    }\n    if (isInclusive) {\n      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    }\n    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  async Filter(_ref7, scope, execute) {\n    let {\n      base,\n      expr\n    } = _ref7;\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of baseValue) {\n        const newScope = scope.createNested(elem);\n        const exprValue = await execute(expr, newScope);\n        if (exprValue.type === \"boolean\" && exprValue.data === true) {\n          yield elem;\n        }\n      }\n    });\n  },\n  async Projection(_ref8, scope, execute) {\n    let {\n      base,\n      expr\n    } = _ref8;\n    const baseValue = await execute(base, scope);\n    if (baseValue.type !== \"object\") {\n      return NULL_VALUE;\n    }\n    const newScope = scope.createNested(baseValue);\n    return execute(expr, newScope);\n  },\n  FuncCall(_ref9, scope, execute) {\n    let {\n      func,\n      args\n    } = _ref9;\n    return func(args, scope, execute);\n  },\n  async PipeFuncCall(_ref10, scope, execute) {\n    let {\n      func,\n      base,\n      args\n    } = _ref10;\n    const baseValue = await execute(base, scope);\n    return func(baseValue, args, scope, execute);\n  },\n  async AccessAttribute(_ref11, scope, execute) {\n    let {\n      base,\n      name\n    } = _ref11;\n    let value = scope.value;\n    if (base) {\n      value = await execute(base, scope);\n    }\n    if (value.type === \"object\") {\n      if (value.data.hasOwnProperty(name)) {\n        return fromJS(value.data[name]);\n      }\n    }\n    return NULL_VALUE;\n  },\n  async AccessElement(_ref12, scope, execute) {\n    let {\n      base,\n      index\n    } = _ref12;\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    const data = await baseValue.get();\n    const finalIndex = index < 0 ? index + data.length : index;\n    return fromJS(data[finalIndex]);\n  },\n  async Slice(_ref13, scope, execute) {\n    let {\n      base,\n      left,\n      right,\n      isInclusive\n    } = _ref13;\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    const array = await baseValue.get();\n    let leftIdx = left;\n    let rightIdx = right;\n    if (leftIdx < 0) {\n      leftIdx = array.length + leftIdx;\n    }\n    if (rightIdx < 0) {\n      rightIdx = array.length + rightIdx;\n    }\n    if (isInclusive) {\n      rightIdx++;\n    }\n    if (leftIdx < 0) {\n      leftIdx = 0;\n    }\n    if (rightIdx < 0) {\n      rightIdx = 0;\n    }\n    return fromJS(array.slice(leftIdx, rightIdx));\n  },\n  async Deref(_ref14, scope, execute) {\n    let {\n      base\n    } = _ref14;\n    const value = await execute(base, scope);\n    if (!scope.source.isArray()) {\n      return NULL_VALUE;\n    }\n    if (value.type !== \"object\") {\n      return NULL_VALUE;\n    }\n    const id = value.data._ref;\n    if (typeof id !== \"string\") {\n      return NULL_VALUE;\n    }\n    if (scope.context.dereference) {\n      return fromJS(await scope.context.dereference({\n        _ref: id\n      }));\n    }\n    for await (const doc of scope.source) {\n      if (doc.type === \"object\" && id === doc.data._id) {\n        return doc;\n      }\n    }\n    return NULL_VALUE;\n  },\n  Value(_ref15) {\n    let {\n      value\n    } = _ref15;\n    return fromJS(value);\n  },\n  Group(_ref16, scope, execute) {\n    let {\n      base\n    } = _ref16;\n    return execute(base, scope);\n  },\n  async Object(_ref17, scope, execute) {\n    let {\n      attributes\n    } = _ref17;\n    const result = {};\n    for (const attr of attributes) {\n      const attrType = attr.type;\n      switch (attr.type) {\n        case \"ObjectAttributeValue\":\n          {\n            const value = await execute(attr.value, scope);\n            result[attr.name] = await value.get();\n            break;\n          }\n        case \"ObjectConditionalSplat\":\n          {\n            const cond = await execute(attr.condition, scope);\n            if (cond.type !== \"boolean\" || cond.data === false) {\n              continue;\n            }\n            const value = await execute(attr.value, scope);\n            if (value.type === \"object\") {\n              Object.assign(result, value.data);\n            }\n            break;\n          }\n        case \"ObjectSplat\":\n          {\n            const value = await execute(attr.value, scope);\n            if (value.type === \"object\") {\n              Object.assign(result, value.data);\n            }\n            break;\n          }\n        default:\n          throw new Error(\"Unknown node type: \".concat(attrType));\n      }\n    }\n    return fromJS(result);\n  },\n  Array(_ref18, scope, execute) {\n    let {\n      elements\n    } = _ref18;\n    return new StreamValue(async function* () {\n      for (const element of elements) {\n        const value = await execute(element.value, scope);\n        if (element.isSplat) {\n          if (value.isArray()) {\n            for await (const v of value) {\n              yield v;\n            }\n          }\n        } else {\n          yield value;\n        }\n      }\n    });\n  },\n  Tuple() {\n    throw new Error(\"tuples can not be evaluated\");\n  },\n  async Or(_ref19, scope, execute) {\n    let {\n      left,\n      right\n    } = _ref19;\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    if (leftValue.type === \"boolean\") {\n      if (leftValue.data === true) {\n        return TRUE_VALUE;\n      }\n    }\n    if (rightValue.type === \"boolean\") {\n      if (rightValue.data === true) {\n        return TRUE_VALUE;\n      }\n    }\n    if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return FALSE_VALUE;\n  },\n  async And(_ref20, scope, execute) {\n    let {\n      left,\n      right\n    } = _ref20;\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    if (leftValue.type === \"boolean\") {\n      if (leftValue.data === false) {\n        return FALSE_VALUE;\n      }\n    }\n    if (rightValue.type === \"boolean\") {\n      if (rightValue.data === false) {\n        return FALSE_VALUE;\n      }\n    }\n    if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return TRUE_VALUE;\n  },\n  async Not(_ref21, scope, execute) {\n    let {\n      base\n    } = _ref21;\n    const value = await execute(base, scope);\n    if (value.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return value.data ? FALSE_VALUE : TRUE_VALUE;\n  },\n  Neg(_ref22, scope, execute) {\n    let {\n      base\n    } = _ref22;\n    return promiselessApply(execute(base, scope), value => {\n      if (value.type !== \"number\") {\n        return NULL_VALUE;\n      }\n      return fromNumber(-value.data);\n    });\n  },\n  Pos(_ref23, scope, execute) {\n    let {\n      base\n    } = _ref23;\n    return promiselessApply(execute(base, scope), value => {\n      if (value.type !== \"number\") {\n        return NULL_VALUE;\n      }\n      return fromNumber(value.data);\n    });\n  },\n  Asc() {\n    return NULL_VALUE;\n  },\n  Desc() {\n    return NULL_VALUE;\n  },\n  async ArrayCoerce(_ref24, scope, execute) {\n    let {\n      base\n    } = _ref24;\n    const value = await execute(base, scope);\n    return value.isArray() ? value : NULL_VALUE;\n  },\n  async Map(_ref25, scope, execute) {\n    let {\n      base,\n      expr\n    } = _ref25;\n    const value = await execute(base, scope);\n    if (!value.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem);\n        yield await execute(expr, newScope);\n      }\n    });\n  },\n  async FlatMap(_ref26, scope, execute) {\n    let {\n      base,\n      expr\n    } = _ref26;\n    const value = await execute(base, scope);\n    if (!value.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem);\n        const innerValue = await execute(expr, newScope);\n        if (innerValue.isArray()) {\n          for await (const inner of innerValue) {\n            yield inner;\n          }\n        } else {\n          yield innerValue;\n        }\n      }\n    });\n  }\n};\nfunction evaluateQuery(tree) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const root = fromJS(options.root);\n  const dataset = fromJS(options.dataset);\n  const params = {\n    ...options.params\n  };\n  const scope = new Scope(params, dataset, root, {\n    timestamp: options.timestamp || /* @__PURE__ */new Date(),\n    identity: options.identity === void 0 ? \"me\" : options.identity,\n    sanity: options.sanity,\n    after: options.after ? fromJS(options.after) : null,\n    before: options.before ? fromJS(options.before) : null,\n    dereference: options.dereference\n  }, null);\n  return evaluate(tree, scope);\n}\nfunction canConstantEvaluate(node) {\n  switch (node.type) {\n    case \"Group\":\n      return canConstantEvaluate(node.base);\n    case \"Value\":\n    case \"Parameter\":\n      return true;\n    case \"Pos\":\n    case \"Neg\":\n      return canConstantEvaluate(node.base);\n    case \"OpCall\":\n      switch (node.op) {\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"%\":\n        case \"**\":\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n        default:\n          return false;\n      }\n    default:\n      return false;\n  }\n}\nconst DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, {\n  timestamp: /* @__PURE__ */new Date(0),\n  identity: \"me\",\n  before: null,\n  after: null\n}, null);\nfunction tryConstantEvaluate(node) {\n  if (!canConstantEvaluate(node)) {\n    return null;\n  }\n  return constantEvaluate(node);\n}\nfunction constantEvaluate(node) {\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n  if (\"then\" in value) {\n    throw new Error(\"BUG: constant evaluate should never return a promise\");\n  }\n  return value;\n}\nasync function portableTextContent(value) {\n  if (value.type === \"object\") {\n    return blockText(value.data);\n  } else if (value.isArray()) {\n    const texts = await arrayText(value);\n    if (texts.length > 0) {\n      return texts.join(\"\\n\\n\");\n    }\n  }\n  return null;\n}\nasync function arrayText(value) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  for await (const block of value) {\n    if (block.type === \"object\") {\n      const text = blockText(block.data);\n      if (text !== null) result.push(text);\n    } else if (block.isArray()) {\n      await arrayText(block, result);\n    }\n  }\n  return result;\n}\nfunction blockText(obj) {\n  if (typeof obj._type !== \"string\") return null;\n  const children = obj.children;\n  if (!Array.isArray(children)) return null;\n  let result = \"\";\n  for (const child of children) {\n    if (child && typeof child === \"object\" && typeof child._type === \"string\" && child._type === \"span\" && typeof child.text === \"string\") {\n      result += child.text;\n    }\n  }\n  return result;\n}\nconst BM25k = 1.2;\nasync function evaluateScore(node, scope, execute) {\n  if (node.type === \"OpCall\" && node.op === \"match\") {\n    return evaluateMatchScore(node.left, node.right, scope, execute);\n  }\n  if (node.type === \"FuncCall\" && node.name === \"boost\") {\n    const innerScore = await evaluateScore(node.args[0], scope, execute);\n    const boost = await execute(node.args[1], scope);\n    if (boost.type === \"number\" && innerScore > 0) {\n      return innerScore + boost.data;\n    }\n    return 0;\n  }\n  switch (node.type) {\n    case \"Or\":\n      {\n        const leftScore = await evaluateScore(node.left, scope, execute);\n        const rightScore = await evaluateScore(node.right, scope, execute);\n        return leftScore + rightScore;\n      }\n    case \"And\":\n      {\n        const leftScore = await evaluateScore(node.left, scope, execute);\n        const rightScore = await evaluateScore(node.right, scope, execute);\n        if (leftScore === 0 || rightScore === 0) return 0;\n        return leftScore + rightScore;\n      }\n    default:\n      {\n        const res = await execute(node, scope);\n        return res.type === \"boolean\" && res.data === true ? 1 : 0;\n      }\n  }\n}\nasync function evaluateMatchScore(left, right, scope, execute) {\n  const text = await execute(left, scope);\n  const pattern = await execute(right, scope);\n  let tokens = [];\n  let terms = [];\n  await gatherText(text, part => {\n    tokens = tokens.concat(matchTokenize(part));\n  });\n  const didSucceed = await gatherText(pattern, part => {\n    terms = terms.concat(matchPatternRegex(part));\n  });\n  if (!didSucceed) {\n    return 0;\n  }\n  if (tokens.length === 0 || terms.length === 0) {\n    return 0;\n  }\n  let score = 0;\n  for (const re of terms) {\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0);\n    score += freq * (BM25k + 1) / (freq + BM25k);\n  }\n  return score;\n}\nfunction hasReference(value, pathSet) {\n  switch (getType(value)) {\n    case \"array\":\n      for (const v of value) {\n        if (hasReference(v, pathSet)) {\n          return true;\n        }\n      }\n      break;\n    case \"object\":\n      if (value._ref) {\n        return pathSet.has(value._ref);\n      }\n      for (const v of Object.values(value)) {\n        if (hasReference(v, pathSet)) {\n          return true;\n        }\n      }\n      break;\n  }\n  return false;\n}\nfunction countUTF8(str) {\n  let count2 = 0;\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    if (code >= 55296 && code <= 56319) {\n      continue;\n    }\n    count2++;\n  }\n  return count2;\n}\nconst _global = {};\n_global.anywhere = async function anywhere() {\n  throw new Error(\"not implemented\");\n};\n_global.anywhere.arity = 1;\n_global.coalesce = async function coalesce(args, scope, execute) {\n  for (const arg of args) {\n    const value = await execute(arg, scope);\n    if (value.type !== \"null\") {\n      return value;\n    }\n  }\n  return NULL_VALUE;\n};\n_global.count = async function count(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (!inner.isArray()) {\n    return NULL_VALUE;\n  }\n  let num = 0;\n  for await (const _ of inner) {\n    num++;\n  }\n  return fromNumber(num);\n};\n_global.count.arity = 1;\n_global.dateTime = async function dateTime(args, scope, execute) {\n  const val = await execute(args[0], scope);\n  if (val.type === \"datetime\") {\n    return val;\n  }\n  if (val.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return DateTime.parseToValue(val.data);\n};\n_global.dateTime.arity = 1;\n_global.defined = async function defined(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  return inner.type === \"null\" ? FALSE_VALUE : TRUE_VALUE;\n};\n_global.defined.arity = 1;\n_global.identity = async function identity(args, scope) {\n  return fromString(scope.context.identity);\n};\n_global.identity.arity = 0;\n_global.length = async function length(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (inner.type === \"string\") {\n    return fromNumber(countUTF8(inner.data));\n  }\n  if (inner.isArray()) {\n    let num = 0;\n    for await (const _ of inner) {\n      num++;\n    }\n    return fromNumber(num);\n  }\n  return NULL_VALUE;\n};\n_global.length.arity = 1;\n_global.path = async function path(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (inner.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromPath(new Path(inner.data));\n};\n_global.path.arity = 1;\n_global.string = async function string(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  switch (value.type) {\n    case \"number\":\n    case \"string\":\n    case \"boolean\":\n    case \"datetime\":\n      return fromString(\"\".concat(value.data));\n    default:\n      return NULL_VALUE;\n  }\n};\n_global.string.arity = 1;\n_global.references = async function references(args, scope, execute) {\n  const pathSet = /* @__PURE__ */new Set();\n  for (const arg of args) {\n    const path2 = await execute(arg, scope);\n    if (path2.type === \"string\") {\n      pathSet.add(path2.data);\n    } else if (path2.isArray()) {\n      for await (const elem of path2) {\n        if (elem.type === \"string\") {\n          pathSet.add(elem.data);\n        }\n      }\n    }\n  }\n  if (pathSet.size === 0) {\n    return FALSE_VALUE;\n  }\n  const scopeValue = await scope.value.get();\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n};\n_global.references.arity = c => c >= 1;\n_global.round = async function round(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"number\") {\n    return NULL_VALUE;\n  }\n  const num = value.data;\n  let prec = 0;\n  if (args.length === 2) {\n    const precValue = await execute(args[1], scope);\n    if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n      return NULL_VALUE;\n    }\n    prec = precValue.data;\n  }\n  if (prec === 0) {\n    if (num < 0) {\n      return fromNumber(-Math.round(-num));\n    }\n    return fromNumber(Math.round(num));\n  }\n  return fromNumber(Number(num.toFixed(prec)));\n};\n_global.round.arity = count2 => count2 >= 1 && count2 <= 2;\n_global.now = async function now(args, scope) {\n  return fromString(scope.context.timestamp.toISOString());\n};\n_global.now.arity = 0;\n_global.boost = async function boost() {\n  throw new Error(\"unexpected boost call\");\n};\n_global.boost.arity = 2;\nconst string2 = {};\nstring2.lower = async function (args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromString(value.data.toLowerCase());\n};\nstring2.lower.arity = 1;\nstring2.upper = async function (args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromString(value.data.toUpperCase());\n};\nstring2.upper.arity = 1;\nstring2.split = async function (args, scope, execute) {\n  const str = await execute(args[0], scope);\n  if (str.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  const sep = await execute(args[1], scope);\n  if (sep.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  if (str.data.length === 0) {\n    return fromJS([]);\n  }\n  if (sep.data.length === 0) {\n    return fromJS(Array.from(str.data));\n  }\n  return fromJS(str.data.split(sep.data));\n};\nstring2.split.arity = 2;\n_global.lower = string2.lower;\n_global.upper = string2.upper;\nstring2.startsWith = async function (args, scope, execute) {\n  const str = await execute(args[0], scope);\n  if (str.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  const prefix = await execute(args[1], scope);\n  if (prefix.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE;\n};\nstring2.startsWith.arity = 2;\nconst array = {};\narray.join = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  const sep = await execute(args[1], scope);\n  if (sep.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  let buf = \"\";\n  let needSep = false;\n  for await (const elem of arr) {\n    if (needSep) {\n      buf += sep.data;\n    }\n    switch (elem.type) {\n      case \"number\":\n      case \"string\":\n      case \"boolean\":\n      case \"datetime\":\n        buf += \"\".concat(elem.data);\n        break;\n      default:\n        return NULL_VALUE;\n    }\n    needSep = true;\n  }\n  return fromJS(buf);\n};\narray.join.arity = 2;\narray.compact = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  return new StreamValue(async function* () {\n    for await (const elem of arr) {\n      if (elem.type !== \"null\") {\n        yield elem;\n      }\n    }\n  });\n};\narray.compact.arity = 1;\narray.unique = async function (args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (!value.isArray()) {\n    return NULL_VALUE;\n  }\n  return new StreamValue(async function* () {\n    const added = /* @__PURE__ */new Set();\n    for await (const iter of value) {\n      switch (iter.type) {\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n        case \"datetime\":\n          if (!added.has(iter.data)) {\n            added.add(iter.data);\n            yield iter;\n          }\n          break;\n        default:\n          yield iter;\n      }\n    }\n  });\n};\narray.unique.arity = 1;\nconst pt = {};\npt.text = async function (args, scope, execute) {\n  const value = await execute(args[0], scope);\n  const text = await portableTextContent(value);\n  if (text === null) {\n    return NULL_VALUE;\n  }\n  return fromString(text);\n};\npt.text.arity = 1;\nconst sanity = {};\nsanity.projectId = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.projectId);\n  }\n  return NULL_VALUE;\n};\nsanity.dataset = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.dataset);\n  }\n  return NULL_VALUE;\n};\nconst pipeFunctions = {};\npipeFunctions.order = async function order(base, args, scope, execute) {\n  await true;\n  if (!base.isArray()) {\n    return NULL_VALUE;\n  }\n  const mappers = [];\n  const directions = [];\n  let n = 0;\n  for (let mapper of args) {\n    let direction = \"asc\";\n    if (mapper.type === \"Desc\") {\n      direction = \"desc\";\n      mapper = mapper.base;\n    } else if (mapper.type === \"Asc\") {\n      mapper = mapper.base;\n    }\n    mappers.push(mapper);\n    directions.push(direction);\n    n++;\n  }\n  const aux = [];\n  let idx = 0;\n  for await (const value of base) {\n    const newScope = scope.createNested(value);\n    const tuple = [await value.get(), idx];\n    for (let i = 0; i < n; i++) {\n      const result = await execute(mappers[i], newScope);\n      tuple.push(await result.get());\n    }\n    aux.push(tuple);\n    idx++;\n  }\n  aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < n; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n      if (directions[i] === \"desc\") {\n        c = -c;\n      }\n      if (c !== 0) {\n        return c;\n      }\n    }\n    return aTuple[1] - bTuple[1];\n  });\n  return fromJS(aux.map(v => v[0]));\n};\npipeFunctions.order.arity = count2 => count2 >= 1;\npipeFunctions.score = async function score(base, args, scope, execute) {\n  if (!base.isArray()) return NULL_VALUE;\n  const unknown = [];\n  const scored = [];\n  for await (const value of base) {\n    if (value.type !== \"object\") {\n      unknown.push(await value.get());\n      continue;\n    }\n    const newScope = scope.createNested(value);\n    let valueScore = typeof value.data._score === \"number\" ? value.data._score : 0;\n    for (const arg of args) {\n      valueScore += await evaluateScore(arg, newScope, execute);\n    }\n    const newObject = Object.assign({}, value.data, {\n      _score: valueScore\n    });\n    scored.push(newObject);\n  }\n  scored.sort((a, b) => b._score - a._score);\n  return fromJS(scored);\n};\npipeFunctions.score.arity = count2 => count2 >= 1;\nconst delta = {};\ndelta.operation = async function (args, scope) {\n  const hasBefore = scope.context.before !== null;\n  const hasAfter = scope.context.after !== null;\n  if (hasBefore && hasAfter) {\n    return fromString(\"update\");\n  }\n  if (hasAfter) {\n    return fromString(\"create\");\n  }\n  if (hasBefore) {\n    return fromString(\"delete\");\n  }\n  return NULL_VALUE;\n};\ndelta.changedAny = () => {\n  throw new Error(\"not implemented\");\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = () => {\n  throw new Error(\"not implemented\");\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst diff = {};\ndiff.changedAny = () => {\n  throw new Error(\"not implemented\");\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = () => {\n  throw new Error(\"not implemented\");\n};\ndiff.changedOnly.arity = 3;\nconst math = {};\nmath.min = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  let n;\n  for await (const elem of arr) {\n    if (elem.type === \"null\") continue;\n    if (elem.type !== \"number\") {\n      return NULL_VALUE;\n    }\n    if (n === void 0 || elem.data < n) {\n      n = elem.data;\n    }\n  }\n  return fromJS(n);\n};\nmath.min.arity = 1;\nmath.max = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  let n;\n  for await (const elem of arr) {\n    if (elem.type === \"null\") continue;\n    if (elem.type !== \"number\") {\n      return NULL_VALUE;\n    }\n    if (n === void 0 || elem.data > n) {\n      n = elem.data;\n    }\n  }\n  return fromJS(n);\n};\nmath.max.arity = 1;\nmath.sum = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  let n = 0;\n  for await (const elem of arr) {\n    if (elem.type === \"null\") continue;\n    if (elem.type !== \"number\") {\n      return NULL_VALUE;\n    }\n    n += elem.data;\n  }\n  return fromJS(n);\n};\nmath.sum.arity = 1;\nmath.avg = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  let n = 0;\n  let c = 0;\n  for await (const elem of arr) {\n    if (elem.type === \"null\") continue;\n    if (elem.type !== \"number\") {\n      return NULL_VALUE;\n    }\n    n += elem.data;\n    c++;\n  }\n  if (c === 0) {\n    return NULL_VALUE;\n  }\n  return fromJS(n / c);\n};\nmath.avg.arity = 1;\nconst dateTime2 = {};\ndateTime2.now = async function now2(args, scope, execute) {\n  return fromDateTime(new DateTime(scope.context.timestamp));\n};\ndateTime2.now.arity = 0;\nconst namespaces = {\n  global: _global,\n  string: string2,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n  dateTime: dateTime2\n};\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass MarkProcessor {\n  constructor(string, marks, parseOptions) {\n    __publicField$1(this, \"string\");\n    __publicField$1(this, \"marks\");\n    __publicField$1(this, \"index\");\n    __publicField$1(this, \"parseOptions\");\n    __publicField$1(this, \"allowBoost\", false);\n    this.string = string;\n    this.marks = marks;\n    this.index = 0;\n    this.parseOptions = parseOptions;\n  }\n  hasMark() {\n    let pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this.index + pos < this.marks.length;\n  }\n  getMark() {\n    let pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this.marks[this.index + pos];\n  }\n  shift() {\n    this.index += 1;\n  }\n  process(visitor) {\n    const mark = this.marks[this.index];\n    this.shift();\n    const func = visitor[mark.name];\n    if (!func) {\n      throw new Error(\"Unknown handler: \".concat(mark.name));\n    }\n    return func.call(visitor, this, mark);\n  }\n  processString() {\n    this.shift();\n    return this.processStringEnd();\n  }\n  processStringEnd() {\n    const prev = this.marks[this.index - 1];\n    const curr = this.marks[this.index];\n    this.shift();\n    return this.string.slice(prev.position, curr.position);\n  }\n  slice(len) {\n    const pos = this.marks[this.index].position;\n    return this.string.slice(pos, pos + len);\n  }\n}\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/;\nconst NUM = /^\\d+/;\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nconst PREC_PAIR = 1;\nconst PREC_OR = 2;\nconst PREC_AND = 3;\nconst PREC_COMP = 4;\nconst PREC_ORDER = 4;\nconst PREC_ADD = 6;\nconst PREC_SUB = 6;\nconst PREC_MUL = 7;\nconst PREC_DIV = 7;\nconst PREC_MOD = 7;\nconst PREC_POW = 8;\nconst PREC_POS = 10;\nconst PREC_NOT = 10;\nconst PREC_NEG = 8;\nfunction parse$1(str) {\n  let pos = 0;\n  pos = skipWS(str, pos);\n  let result = parseExpr(str, pos, 0);\n  if (result.type === \"error\") return result;\n  pos = skipWS(str, result.position);\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1;\n    }\n    return {\n      type: \"error\",\n      position: pos\n    };\n  }\n  delete result.position;\n  delete result.failPosition;\n  return result;\n}\nfunction parseExpr(str, pos, level) {\n  let startPos = pos;\n  let token = str[pos];\n  let marks;\n  switch (token) {\n    case \"+\":\n      {\n        let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);\n        if (rhs.type === \"error\") return rhs;\n        marks = [{\n          name: \"pos\",\n          position: startPos\n        }].concat(rhs.marks);\n        pos = rhs.position;\n        break;\n      }\n    case \"-\":\n      {\n        let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);\n        if (rhs.type === \"error\") return rhs;\n        marks = [{\n          name: \"neg\",\n          position: startPos\n        }].concat(rhs.marks);\n        pos = rhs.position;\n        break;\n      }\n    case \"(\":\n      {\n        let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n        if (rhs.type === \"error\") return rhs;\n        pos = skipWS(str, rhs.position);\n        switch (str[pos]) {\n          case \",\":\n            {\n              marks = [{\n                name: \"tuple\",\n                position: startPos\n              }].concat(rhs.marks);\n              pos = skipWS(str, pos + 1);\n              while (true) {\n                rhs = parseExpr(str, pos, 0);\n                if (rhs.type === \"error\") return rhs;\n                pos = skipWS(str, rhs.position);\n                if (str[pos] !== \",\") break;\n                pos = skipWS(str, pos + 1);\n              }\n              if (str[pos] !== \")\") return {\n                type: \"error\",\n                position: pos\n              };\n              pos++;\n              marks.push({\n                name: \"tuple_end\",\n                position: pos\n              });\n              break;\n            }\n          case \")\":\n            {\n              pos++;\n              marks = [{\n                name: \"group\",\n                position: startPos\n              }].concat(rhs.marks);\n              break;\n            }\n          default:\n            return {\n              type: \"error\",\n              position: pos\n            };\n        }\n        break;\n      }\n    case \"!\":\n      {\n        let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);\n        if (rhs.type === \"error\") return rhs;\n        marks = [{\n          name: \"not\",\n          position: startPos\n        }].concat(rhs.marks);\n        pos = rhs.position;\n        break;\n      }\n    case \"{\":\n      {\n        let result = parseObject(str, pos);\n        if (result.type === \"error\") return result;\n        marks = result.marks;\n        pos = result.position;\n        break;\n      }\n    case \"[\":\n      marks = [{\n        name: \"array\",\n        position: pos\n      }];\n      pos = skipWS(str, pos + 1);\n      if (str[pos] !== \"]\") {\n        while (true) {\n          if (str.slice(pos, pos + 3) === \"...\") {\n            marks.push({\n              name: \"array_splat\",\n              position: pos\n            });\n            pos = skipWS(str, pos + 3);\n          }\n          let res = parseExpr(str, pos, 0);\n          if (res.type === \"error\") return res;\n          marks = marks.concat(res.marks);\n          pos = res.position;\n          pos = skipWS(str, pos);\n          if (str[pos] !== \",\") break;\n          pos = skipWS(str, pos + 1);\n          if (str[pos] === \"]\") break;\n        }\n      }\n      if (str[pos] === \"]\") {\n        pos++;\n        marks.push({\n          name: \"array_end\",\n          position: pos\n        });\n      } else {\n        return {\n          type: \"error\",\n          position: pos\n        };\n      }\n      break;\n    case \"'\":\n    case '\"':\n      {\n        let result = parseString(str, pos);\n        if (result.type === \"error\") return result;\n        marks = result.marks;\n        pos = result.position;\n        break;\n      }\n    case \"^\":\n      {\n        pos++;\n        marks = [];\n        while (str[pos] === \".\" && str[pos + 1] === \"^\") {\n          marks.push({\n            name: \"dblparent\",\n            position: startPos\n          });\n          pos += 2;\n        }\n        marks.push({\n          name: \"parent\",\n          position: startPos\n        });\n        break;\n      }\n    case \"@\":\n      marks = [{\n        name: \"this\",\n        position: startPos\n      }];\n      pos++;\n      break;\n    case \"*\":\n      marks = [{\n        name: \"everything\",\n        position: startPos\n      }];\n      pos++;\n      break;\n    case \"$\":\n      {\n        let identLen = parseRegex(str, pos + 1, IDENT);\n        if (identLen) {\n          pos += 1 + identLen;\n          marks = [{\n            name: \"param\",\n            position: startPos\n          }, {\n            name: \"ident\",\n            position: startPos + 1\n          }, {\n            name: \"ident_end\",\n            position: pos\n          }];\n        }\n        break;\n      }\n    default:\n      {\n        let numLen = parseRegex(str, pos, NUM);\n        if (numLen) {\n          pos += numLen;\n          let name = \"integer\";\n          if (str[pos] === \".\") {\n            let fracLen = parseRegex(str, pos + 1, NUM);\n            if (fracLen) {\n              name = \"float\";\n              pos += 1 + fracLen;\n            }\n          }\n          if (str[pos] === \"e\" || str[pos] === \"E\") {\n            name = \"sci\";\n            pos++;\n            if (str[pos] === \"+\" || str[pos] === \"-\") {\n              pos++;\n            }\n            let expLen = parseRegex(str, pos, NUM);\n            if (!expLen) return {\n              type: \"error\",\n              position: pos\n            };\n            pos += expLen;\n          }\n          marks = [{\n            name,\n            position: startPos\n          }, {\n            name: name + \"_end\",\n            position: pos\n          }];\n          break;\n        }\n        let identLen = parseRegex(str, pos, IDENT);\n        if (identLen) {\n          pos += identLen;\n          switch (str[pos]) {\n            case \":\":\n            case \"(\":\n              {\n                let result = parseFuncCall(str, startPos, pos);\n                if (result.type === \"error\") return result;\n                marks = result.marks;\n                pos = result.position;\n                break;\n              }\n            default:\n              {\n                marks = [{\n                  name: \"this_attr\",\n                  position: startPos\n                }, {\n                  name: \"ident\",\n                  position: startPos\n                }, {\n                  name: \"ident_end\",\n                  position: pos\n                }];\n              }\n          }\n          break;\n        }\n      }\n  }\n  if (!marks) {\n    return {\n      type: \"error\",\n      position: pos\n    };\n  }\n  let lhsLevel = 12;\n  let trav;\n  loop: while (true) {\n    let innerPos = skipWS(str, pos);\n    if (innerPos === str.length) {\n      pos = innerPos;\n      break;\n    }\n    trav = parseTraversal(str, innerPos);\n    if (trav.type === \"success\") {\n      marks.unshift({\n        name: \"traverse\",\n        position: startPos\n      });\n      while (trav.type === \"success\") {\n        marks = marks.concat(trav.marks);\n        pos = trav.position;\n        trav = parseTraversal(str, skipWS(str, pos));\n      }\n      marks.push({\n        name: \"traversal_end\",\n        position: pos\n      });\n      continue;\n    }\n    let token2 = str[innerPos];\n    switch (token2) {\n      case \"=\":\n        {\n          let nextToken = str[innerPos + 1];\n          switch (nextToken) {\n            case \">\":\n              {\n                if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop;\n                let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);\n                if (rhs.type === \"error\") return rhs;\n                marks = marks.concat(rhs.marks);\n                marks.unshift({\n                  name: \"pair\",\n                  position: startPos\n                });\n                pos = rhs.position;\n                lhsLevel = PREC_PAIR;\n                break;\n              }\n            case \"=\":\n              {\n                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n                if (rhs.type === \"error\") return rhs;\n                marks.unshift({\n                  name: \"comp\",\n                  position: startPos\n                });\n                marks.push({\n                  name: \"op\",\n                  position: innerPos\n                }, {\n                  name: \"op_end\",\n                  position: innerPos + 2\n                });\n                marks = marks.concat(rhs.marks);\n                pos = rhs.position;\n                lhsLevel = PREC_COMP;\n                break;\n              }\n            default:\n              break loop;\n          }\n          break;\n        }\n      case \"+\":\n        {\n          if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({\n            name: \"add\",\n            position: startPos\n          });\n          pos = rhs.position;\n          lhsLevel = PREC_ADD;\n          break;\n        }\n      case \"-\":\n        {\n          if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({\n            name: \"sub\",\n            position: startPos\n          });\n          pos = rhs.position;\n          lhsLevel = PREC_SUB;\n          break;\n        }\n      case \"*\":\n        {\n          if (str[innerPos + 1] === \"*\") {\n            if (level > PREC_POW || lhsLevel <= PREC_POW) break loop;\n            let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);\n            if (rhs2.type === \"error\") return rhs2;\n            marks = marks.concat(rhs2.marks);\n            marks.unshift({\n              name: \"pow\",\n              position: startPos\n            });\n            pos = rhs2.position;\n            lhsLevel = PREC_POW;\n            break;\n          }\n          if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({\n            name: \"mul\",\n            position: startPos\n          });\n          pos = rhs.position;\n          lhsLevel = PREC_MUL;\n          break;\n        }\n      case \"/\":\n        {\n          if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({\n            name: \"div\",\n            position: startPos\n          });\n          pos = rhs.position;\n          lhsLevel = PREC_DIV;\n          break;\n        }\n      case \"%\":\n        {\n          if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({\n            name: \"mod\",\n            position: startPos\n          });\n          pos = rhs.position;\n          lhsLevel = PREC_MOD;\n          break;\n        }\n      case \"<\":\n      case \">\":\n        {\n          if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n          let nextPos = innerPos + 1;\n          if (str[nextPos] === \"=\") {\n            nextPos++;\n          }\n          let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks.unshift({\n            name: \"comp\",\n            position: startPos\n          });\n          marks.push({\n            name: \"op\",\n            position: innerPos\n          }, {\n            name: \"op_end\",\n            position: nextPos\n          });\n          marks = marks.concat(rhs.marks);\n          pos = rhs.position;\n          lhsLevel = PREC_COMP;\n          break;\n        }\n      case \"|\":\n        {\n          if (str[innerPos + 1] === \"|\") {\n            if (level > PREC_OR || lhsLevel < PREC_OR) break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);\n            if (rhs.type === \"error\") return rhs;\n            marks = marks.concat(rhs.marks);\n            marks.unshift({\n              name: \"or\",\n              position: startPos\n            });\n            pos = rhs.position;\n            lhsLevel = PREC_OR;\n          } else {\n            if (level > 11 || lhsLevel < 11) break loop;\n            let identPos = skipWS(str, innerPos + 1);\n            let identLen = parseRegex(str, identPos, IDENT);\n            if (!identLen) return {\n              type: \"error\",\n              position: identPos\n            };\n            pos = identPos + identLen;\n            if (str[pos] === \"(\" || str[pos] === \":\") {\n              let result = parseFuncCall(str, identPos, pos);\n              if (result.type === \"error\") return result;\n              marks = marks.concat(result.marks);\n              marks.unshift({\n                name: \"pipecall\",\n                position: startPos\n              });\n              pos = result.position;\n              lhsLevel = 11;\n            }\n          }\n          break;\n        }\n      case \"&\":\n        {\n          if (str[innerPos + 1] != \"&\") break loop;\n          if (level > PREC_AND || lhsLevel < PREC_AND) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({\n            name: \"and\",\n            position: startPos\n          });\n          pos = rhs.position;\n          lhsLevel = PREC_AND;\n          break;\n        }\n      case \"!\":\n        {\n          if (str[innerPos + 1] !== \"=\") break loop;\n          if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n          if (rhs.type === \"error\") return rhs;\n          marks.unshift({\n            name: \"comp\",\n            position: startPos\n          });\n          marks.push({\n            name: \"op\",\n            position: innerPos\n          }, {\n            name: \"op_end\",\n            position: innerPos + 2\n          });\n          marks = marks.concat(rhs.marks);\n          pos = rhs.position;\n          lhsLevel = PREC_COMP;\n          break;\n        }\n      case \"d\":\n        {\n          if (str.slice(innerPos, innerPos + 4) !== \"desc\") break loop;\n          if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop;\n          marks.unshift({\n            name: \"desc\",\n            position: startPos\n          });\n          pos = innerPos + 4;\n          lhsLevel = PREC_ORDER;\n          break;\n        }\n      case \"a\":\n        {\n          if (str.slice(innerPos, innerPos + 3) !== \"asc\") break loop;\n          if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop;\n          marks.unshift({\n            name: \"asc\",\n            position: startPos\n          });\n          pos = innerPos + 3;\n          lhsLevel = PREC_ORDER;\n          break;\n        }\n      default:\n        {\n          let ident = parseRegexStr(str, innerPos, IDENT);\n          switch (ident) {\n            case \"in\":\n              {\n                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                pos = skipWS(str, innerPos + 2);\n                let isGroup = false;\n                if (str[pos] === \"(\") {\n                  isGroup = true;\n                  pos = skipWS(str, pos + 1);\n                }\n                let rangePos = pos;\n                let result = parseExpr(str, pos, PREC_COMP + 1);\n                if (result.type === \"error\") return result;\n                pos = skipWS(str, result.position);\n                if (str[pos] === \".\" && str[pos + 1] === \".\") {\n                  let type = \"inc_range\";\n                  if (str[pos + 2] === \".\") {\n                    type = \"exc_range\";\n                    pos = skipWS(str, pos + 3);\n                  } else {\n                    pos = skipWS(str, pos + 2);\n                  }\n                  let rhs = parseExpr(str, pos, PREC_COMP + 1);\n                  if (rhs.type === \"error\") return rhs;\n                  marks.unshift({\n                    name: \"in_range\",\n                    position: startPos\n                  });\n                  marks = marks.concat({\n                    name: type,\n                    position: rangePos\n                  }, result.marks, rhs.marks);\n                  pos = rhs.position;\n                } else {\n                  marks.unshift({\n                    name: \"comp\",\n                    position: startPos\n                  });\n                  marks.push({\n                    name: \"op\",\n                    position: innerPos\n                  }, {\n                    name: \"op_end\",\n                    position: innerPos + 2\n                  });\n                  marks = marks.concat(result.marks);\n                }\n                if (isGroup) {\n                  pos = skipWS(str, pos);\n                  if (str[pos] !== \")\") return {\n                    type: \"error\",\n                    position: pos\n                  };\n                  pos++;\n                }\n                lhsLevel = PREC_COMP;\n                break;\n              }\n            case \"match\":\n              {\n                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);\n                if (rhs.type === \"error\") return rhs;\n                marks.unshift({\n                  name: \"comp\",\n                  position: startPos\n                });\n                marks.push({\n                  name: \"op\",\n                  position: innerPos\n                }, {\n                  name: \"op_end\",\n                  position: innerPos + 5\n                });\n                marks = marks.concat(rhs.marks);\n                pos = rhs.position;\n                lhsLevel = 4;\n                break;\n              }\n            default:\n              {\n                break loop;\n              }\n          }\n        }\n    }\n  }\n  let failPosition = (trav == null ? void 0 : trav.type) === \"error\" && trav.position;\n  return {\n    type: \"success\",\n    marks,\n    position: pos,\n    failPosition\n  };\n}\nfunction parseTraversal(str, pos) {\n  let startPos = pos;\n  switch (str[pos]) {\n    case \".\":\n      {\n        pos = skipWS(str, pos + 1);\n        let identStart = pos;\n        let identLen2 = parseRegex(str, pos, IDENT);\n        if (!identLen2) return {\n          type: \"error\",\n          position: pos\n        };\n        pos += identLen2;\n        return {\n          type: \"success\",\n          marks: [{\n            name: \"attr_access\",\n            position: startPos\n          }, {\n            name: \"ident\",\n            position: identStart\n          }, {\n            name: \"ident_end\",\n            position: pos\n          }],\n          position: pos\n        };\n      }\n    case \"-\":\n      if (str[pos + 1] !== \">\") return {\n        type: \"error\",\n        position: pos\n      };\n      let marks = [{\n        name: \"deref\",\n        position: startPos\n      }];\n      pos += 2;\n      let identPos = skipWS(str, pos);\n      let identLen = parseRegex(str, identPos, IDENT);\n      if (identLen) {\n        pos = identPos + identLen;\n        marks.push({\n          name: \"deref_attr\",\n          position: identPos\n        }, {\n          name: \"ident\",\n          position: identPos\n        }, {\n          name: \"ident_end\",\n          position: pos\n        });\n      }\n      return {\n        type: \"success\",\n        marks,\n        position: pos\n      };\n    case \"[\":\n      {\n        pos = skipWS(str, pos + 1);\n        if (str[pos] === \"]\") {\n          return {\n            type: \"success\",\n            marks: [{\n              name: \"array_postfix\",\n              position: startPos\n            }],\n            position: pos + 1\n          };\n        }\n        let rangePos = pos;\n        let result = parseExpr(str, pos, 0);\n        if (result.type === \"error\") return result;\n        pos = skipWS(str, result.position);\n        if (str[pos] === \".\" && str[pos + 1] === \".\") {\n          let type = \"inc_range\";\n          if (str[pos + 2] === \".\") {\n            type = \"exc_range\";\n            pos += 3;\n          } else {\n            pos += 2;\n          }\n          pos = skipWS(str, pos);\n          let rhs = parseExpr(str, pos, 0);\n          if (rhs.type === \"error\") return rhs;\n          pos = skipWS(str, rhs.position);\n          if (str[pos] !== \"]\") return {\n            type: \"error\",\n            position: pos\n          };\n          return {\n            type: \"success\",\n            marks: [{\n              name: \"slice\",\n              position: startPos\n            }, {\n              name: type,\n              position: rangePos\n            }].concat(result.marks, rhs.marks),\n            position: pos + 1\n          };\n        }\n        if (str[pos] !== \"]\") return {\n          type: \"error\",\n          position: pos\n        };\n        return {\n          type: \"success\",\n          marks: [{\n            name: \"square_bracket\",\n            position: startPos\n          }].concat(result.marks),\n          position: pos + 1\n        };\n      }\n    case \"|\":\n      {\n        pos = skipWS(str, pos + 1);\n        if (str[pos] === \"{\") {\n          let result = parseObject(str, pos);\n          if (result.type === \"error\") return result;\n          result.marks.unshift({\n            name: \"projection\",\n            position: startPos\n          });\n          return result;\n        }\n        break;\n      }\n    case \"{\":\n      {\n        let result = parseObject(str, pos);\n        if (result.type === \"error\") return result;\n        result.marks.unshift({\n          name: \"projection\",\n          position: startPos\n        });\n        return result;\n      }\n  }\n  return {\n    type: \"error\",\n    position: pos\n  };\n}\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = [];\n  marks.push({\n    name: \"func_call\",\n    position: startPos\n  });\n  if (str[pos] === \":\" && str[pos + 1] === \":\") {\n    marks.push({\n      name: \"namespace\",\n      position: startPos\n    });\n    marks.push({\n      name: \"ident\",\n      position: startPos\n    }, {\n      name: \"ident_end\",\n      position: pos\n    });\n    pos = skipWS(str, pos + 2);\n    let nameLen = parseRegex(str, pos, IDENT);\n    if (!nameLen) return {\n      type: \"error\",\n      position: pos\n    };\n    marks.push({\n      name: \"ident\",\n      position: pos\n    }, {\n      name: \"ident_end\",\n      position: pos + nameLen\n    });\n    pos = skipWS(str, pos + nameLen);\n    if (str[pos] !== \"(\") return {\n      type: \"error\",\n      position: pos\n    };\n    pos++;\n    pos = skipWS(str, pos);\n  } else {\n    marks.push({\n      name: \"ident\",\n      position: startPos\n    }, {\n      name: \"ident_end\",\n      position: pos\n    });\n    pos = skipWS(str, pos + 1);\n  }\n  let lastPos = pos;\n  if (str[pos] !== \")\") {\n    while (true) {\n      let result = parseExpr(str, pos, 0);\n      if (result.type === \"error\") return result;\n      marks = marks.concat(result.marks);\n      lastPos = result.position;\n      pos = skipWS(str, result.position);\n      if (str[pos] !== \",\") break;\n      pos = skipWS(str, pos + 1);\n      if (str[pos] === \")\") break;\n    }\n  }\n  if (str[pos] !== \")\") {\n    return {\n      type: \"error\",\n      position: pos\n    };\n  }\n  marks.push({\n    name: \"func_args_end\",\n    position: lastPos\n  });\n  return {\n    type: \"success\",\n    marks,\n    position: pos + 1\n  };\n}\nfunction parseObject(str, pos) {\n  let marks = [{\n    name: \"object\",\n    position: pos\n  }];\n  pos = skipWS(str, pos + 1);\n  while (str[pos] !== \"}\") {\n    let pairPos = pos;\n    if (str.slice(pos, pos + 3) === \"...\") {\n      pos = skipWS(str, pos + 3);\n      if (str[pos] !== \"}\" && str[pos] !== \",\") {\n        let expr = parseExpr(str, pos, 0);\n        if (expr.type === \"error\") return expr;\n        marks.push({\n          name: \"object_splat\",\n          position: pairPos\n        });\n        marks = marks.concat(expr.marks);\n        pos = expr.position;\n      } else {\n        marks.push({\n          name: \"object_splat_this\",\n          position: pairPos\n        });\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0);\n      if (expr.type === \"error\") return expr;\n      let nextPos = skipWS(str, expr.position);\n      if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n        if (value.type === \"error\") return value;\n        marks.push({\n          name: \"object_pair\",\n          position: pairPos\n        });\n        marks = marks.concat(expr.marks, value.marks);\n        pos = value.position;\n      } else {\n        marks = marks.concat({\n          name: \"object_expr\",\n          position: pos\n        }, expr.marks);\n        pos = expr.position;\n      }\n    }\n    pos = skipWS(str, pos);\n    if (str[pos] !== \",\") break;\n    pos = skipWS(str, pos + 1);\n  }\n  if (str[pos] !== \"}\") {\n    return {\n      type: \"error\",\n      position: pos\n    };\n  }\n  pos++;\n  marks.push({\n    name: \"object_end\",\n    position: pos\n  });\n  return {\n    type: \"success\",\n    marks,\n    position: pos\n  };\n}\nfunction parseString(str, pos) {\n  let token = str[pos];\n  pos = pos + 1;\n  const marks = [{\n    name: \"str\",\n    position: pos\n  }];\n  str: for (;; pos++) {\n    if (pos > str.length) return {\n      type: \"error\",\n      position: pos\n    };\n    switch (str[pos]) {\n      case token:\n        {\n          marks.push({\n            name: \"str_end\",\n            position: pos\n          });\n          pos++;\n          break str;\n        }\n      case \"\\\\\":\n        {\n          marks.push({\n            name: \"str_pause\",\n            position: pos\n          });\n          if (str[pos + 1] === \"u\") {\n            if (str[pos + 2] === \"{\") {\n              marks.push({\n                name: \"unicode_hex\",\n                position: pos + 3\n              });\n              pos = str.indexOf(\"}\", pos + 3);\n              marks.push({\n                name: \"unicode_hex_end\",\n                position: pos\n              });\n            } else {\n              marks.push({\n                name: \"unicode_hex\",\n                position: pos + 2\n              });\n              marks.push({\n                name: \"unicode_hex_end\",\n                position: pos + 6\n              });\n              pos += 5;\n            }\n          } else {\n            marks.push({\n              name: \"single_escape\",\n              position: pos + 1\n            });\n            pos += 1;\n          }\n          marks.push({\n            name: \"str_start\",\n            position: pos + 1\n          });\n        }\n    }\n  }\n  return {\n    type: \"success\",\n    marks,\n    position: pos\n  };\n}\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0] : null;\n}\nfunction join(a, b) {\n  return base => b(a(base));\n}\nfunction map(inner) {\n  return base => ({\n    type: \"Map\",\n    base,\n    expr: inner({\n      type: \"This\"\n    })\n  });\n}\nfunction flatMap(inner) {\n  return base => ({\n    type: \"FlatMap\",\n    base,\n    expr: inner({\n      type: \"This\"\n    })\n  });\n}\nfunction traverseArray(build, right) {\n  if (!right) {\n    return {\n      type: \"a-a\",\n      build\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(build, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"a-a\",\n        build: join(build, map(right.build))\n      };\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, flatMap(right.build))\n      };\n    default:\n      throw new Error(\"unknown type: \".concat(right.type));\n  }\n}\nfunction traversePlain(mapper, right) {\n  if (!right) {\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(\"unknown type: \".concat(right.type));\n  }\n}\nfunction traverseElement(mapper, right) {\n  if (!right) {\n    return {\n      type: \"a-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"a-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(\"unknown type: \".concat(right.type));\n  }\n}\nfunction traverseProjection(mapper, right) {\n  if (!right) {\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(map(mapper), right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(map(mapper), right.build)\n      };\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(\"unknown type: \".concat(right.type));\n  }\n}\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst ESCAPE_SEQUENCE = {\n  \"'\": \"'\",\n  '\"': '\"',\n  \"\\\\\": \"\\\\\",\n  \"/\": \"/\",\n  b: \"\\b\",\n  f: \"\\f\",\n  n: \"\\n\",\n  r: \"\\r\",\n  t: \"\t\"\n};\nfunction expandHex(str) {\n  const charCode = parseInt(str, 16);\n  return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"name\", \"GroqQueryError\");\n  }\n}\nconst EXPR_BUILDER = {\n  group(p) {\n    const inner = p.process(EXPR_BUILDER);\n    return {\n      type: \"Group\",\n      base: inner\n    };\n  },\n  everything() {\n    return {\n      type: \"Everything\"\n    };\n  },\n  this() {\n    return {\n      type: \"This\"\n    };\n  },\n  parent() {\n    return {\n      type: \"Parent\",\n      n: 1\n    };\n  },\n  dblparent(p) {\n    const next = p.process(EXPR_BUILDER);\n    return {\n      type: \"Parent\",\n      n: next.n + 1\n    };\n  },\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER);\n    const traversalList = [];\n    while (p.getMark().name !== \"traversal_end\") {\n      traversalList.push(p.process(TRAVERSE_BUILDER));\n    }\n    p.shift();\n    let traversal = null;\n    for (let i = traversalList.length - 1; i >= 0; i--) {\n      traversal = traversalList[i](traversal);\n    }\n    if (base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") {\n      traversal = traverseArray(val => val, traversal);\n    }\n    if (traversal === null) throw new Error(\"BUG: unexpected empty traversal\");\n    return traversal.build(base);\n  },\n  this_attr(p) {\n    const name = p.processString();\n    if (name === \"null\") {\n      return {\n        type: \"Value\",\n        value: null\n      };\n    }\n    if (name === \"true\") {\n      return {\n        type: \"Value\",\n        value: true\n      };\n    }\n    if (name === \"false\") {\n      return {\n        type: \"Value\",\n        value: false\n      };\n    }\n    return {\n      type: \"AccessAttribute\",\n      name\n    };\n  },\n  neg(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Neg\",\n      base\n    };\n  },\n  pos(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Pos\",\n      base\n    };\n  },\n  add(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"+\",\n      left,\n      right\n    };\n  },\n  sub(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"-\",\n      left,\n      right\n    };\n  },\n  mul(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"*\",\n      left,\n      right\n    };\n  },\n  div(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"/\",\n      left,\n      right\n    };\n  },\n  mod(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"%\",\n      left,\n      right\n    };\n  },\n  pow(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"**\",\n      left,\n      right\n    };\n  },\n  comp(p) {\n    const left = p.process(EXPR_BUILDER);\n    const op = p.processString();\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op,\n      left,\n      right\n    };\n  },\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER);\n    const isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"InRange\",\n      base,\n      left,\n      right,\n      isInclusive\n    };\n  },\n  str(p) {\n    let value = \"\";\n    loop: while (p.hasMark()) {\n      const mark = p.getMark();\n      switch (mark.name) {\n        case \"str_end\":\n          value += p.processStringEnd();\n          break loop;\n        case \"str_pause\":\n          value += p.processStringEnd();\n          break;\n        case \"str_start\":\n          p.shift();\n          break;\n        case \"single_escape\":\n          {\n            const char = p.slice(1);\n            p.shift();\n            value += ESCAPE_SEQUENCE[char];\n            break;\n          }\n        case \"unicode_hex\":\n          p.shift();\n          value += expandHex(p.processStringEnd());\n          break;\n        default:\n          throw new Error(\"unexpected mark: \".concat(mark.name));\n      }\n    }\n    return {\n      type: \"Value\",\n      value\n    };\n  },\n  integer(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  float(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  sci(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  object(p) {\n    const attributes = [];\n    while (p.getMark().name !== \"object_end\") {\n      attributes.push(p.process(OBJECT_BUILDER));\n    }\n    p.shift();\n    return {\n      type: \"Object\",\n      attributes\n    };\n  },\n  array(p) {\n    const elements = [];\n    while (p.getMark().name !== \"array_end\") {\n      let isSplat = false;\n      if (p.getMark().name === \"array_splat\") {\n        isSplat = true;\n        p.shift();\n      }\n      const value = p.process(EXPR_BUILDER);\n      elements.push({\n        type: \"ArrayElement\",\n        value,\n        isSplat\n      });\n    }\n    p.shift();\n    return {\n      type: \"Array\",\n      elements\n    };\n  },\n  tuple(p) {\n    const members = [];\n    while (p.getMark().name !== \"tuple_end\") {\n      members.push(p.process(EXPR_BUILDER));\n    }\n    p.shift();\n    return {\n      type: \"Tuple\",\n      members\n    };\n  },\n  func_call(p) {\n    let namespace = \"global\";\n    if (p.getMark().name === \"namespace\") {\n      p.shift();\n      namespace = p.processString();\n    }\n    const name = p.processString();\n    if (namespace === \"global\" && name === \"select\") {\n      const result = {\n        type: \"Select\",\n        alternatives: []\n      };\n      while (p.getMark().name !== \"func_args_end\") {\n        if (p.getMark().name === \"pair\") {\n          if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n          p.shift();\n          const condition = p.process(EXPR_BUILDER);\n          const value = p.process(EXPR_BUILDER);\n          result.alternatives.push({\n            type: \"SelectAlternative\",\n            condition,\n            value\n          });\n        } else {\n          if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n          const value = p.process(EXPR_BUILDER);\n          result.fallback = value;\n        }\n      }\n      p.shift();\n      return result;\n    }\n    const args = [];\n    while (p.getMark().name !== \"func_args_end\") {\n      if (argumentShouldBeSelector(namespace, name, args.length)) {\n        p.process(SELECTOR_BUILDER);\n        args.push({\n          type: \"Selector\"\n        });\n      } else {\n        args.push(p.process(EXPR_BUILDER));\n      }\n    }\n    p.shift();\n    if (namespace === \"global\" && (name === \"before\" || name === \"after\")) {\n      if (p.parseOptions.mode === \"delta\") {\n        return {\n          type: \"Context\",\n          key: name\n        };\n      }\n    }\n    if (namespace === \"global\" && name === \"boost\" && !p.allowBoost) throw new GroqQueryError(\"unexpected boost\");\n    const funcs = namespaces[namespace];\n    if (!funcs) {\n      throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n    }\n    const func = funcs[name];\n    if (!func) {\n      throw new GroqQueryError(\"Undefined function: \".concat(name));\n    }\n    if (func.arity !== void 0) {\n      validateArity(name, func.arity, args.length);\n    }\n    if (func.mode !== void 0 && func.mode !== p.parseOptions.mode) {\n      throw new GroqQueryError(\"Undefined function: \".concat(name));\n    }\n    return {\n      type: \"FuncCall\",\n      func,\n      namespace,\n      name,\n      args\n    };\n  },\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER);\n    p.shift();\n    let namespace = \"global\";\n    if (p.getMark().name === \"namespace\") {\n      p.shift();\n      namespace = p.processString();\n    }\n    if (namespace !== \"global\") {\n      throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n    }\n    const name = p.processString();\n    const args = [];\n    const oldAllowBoost = p.allowBoost;\n    if (name === \"score\") {\n      p.allowBoost = true;\n    }\n    for (;;) {\n      const markName = p.getMark().name;\n      if (markName === \"func_args_end\") {\n        break;\n      }\n      if (name === \"order\") {\n        if (markName === \"asc\") {\n          p.shift();\n          args.push({\n            type: \"Asc\",\n            base: p.process(EXPR_BUILDER)\n          });\n          continue;\n        } else if (markName === \"desc\") {\n          p.shift();\n          args.push({\n            type: \"Desc\",\n            base: p.process(EXPR_BUILDER)\n          });\n          continue;\n        }\n      }\n      args.push(p.process(EXPR_BUILDER));\n    }\n    p.shift();\n    p.allowBoost = oldAllowBoost;\n    const func = pipeFunctions[name];\n    if (!func) {\n      throw new GroqQueryError(\"Undefined pipe function: \".concat(name));\n    }\n    if (func.arity) {\n      validateArity(name, func.arity, args.length);\n    }\n    return {\n      type: \"PipeFuncCall\",\n      func,\n      base,\n      name,\n      args\n    };\n  },\n  pair(p) {\n    throw new GroqQueryError(\"unexpected =>\");\n  },\n  and(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"And\",\n      left,\n      right\n    };\n  },\n  or(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"Or\",\n      left,\n      right\n    };\n  },\n  not(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Not\",\n      base\n    };\n  },\n  asc(p) {\n    throw new GroqQueryError(\"unexpected asc\");\n  },\n  desc(p) {\n    throw new GroqQueryError(\"unexpected desc\");\n  },\n  param(p) {\n    const name = p.processString();\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n      return {\n        type: \"Value\",\n        value: p.parseOptions.params[name]\n      };\n    }\n    return {\n      type: \"Parameter\",\n      name\n    };\n  }\n};\nconst OBJECT_BUILDER = {\n  object_expr(p) {\n    if (p.getMark().name === \"pair\") {\n      p.shift();\n      const condition = p.process(EXPR_BUILDER);\n      const value2 = p.process(EXPR_BUILDER);\n      return {\n        type: \"ObjectConditionalSplat\",\n        condition,\n        value: value2\n      };\n    }\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: extractPropertyKey(value),\n      value\n    };\n  },\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER);\n    if (name.type !== \"Value\") throw new Error(\"name must be string\");\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: name.value,\n      value\n    };\n  },\n  object_splat(p) {\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectSplat\",\n      value\n    };\n  },\n  object_splat_this() {\n    return {\n      type: \"ObjectSplat\",\n      value: {\n        type: \"This\"\n      }\n    };\n  }\n};\nconst TRAVERSE_BUILDER = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER);\n    const value = tryConstantEvaluate(expr);\n    if (value && value.type === \"number\") {\n      return right => traverseElement(base => ({\n        type: \"AccessElement\",\n        base,\n        index: value.data\n      }), right);\n    }\n    if (value && value.type === \"string\") {\n      return right => traversePlain(base => ({\n        type: \"AccessAttribute\",\n        base,\n        name: value.data\n      }), right);\n    }\n    return right => traverseArray(base => ({\n      type: \"Filter\",\n      base,\n      expr\n    }), right);\n  },\n  slice(p) {\n    const isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    const leftValue = tryConstantEvaluate(left);\n    const rightValue = tryConstantEvaluate(right);\n    if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\") {\n      throw new GroqQueryError(\"slicing must use constant numbers\");\n    }\n    return rhs => traverseArray(base => ({\n      type: \"Slice\",\n      base,\n      left: leftValue.data,\n      right: rightValue.data,\n      isInclusive\n    }), rhs);\n  },\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER);\n    return right => traverseProjection(base => ({\n      type: \"Projection\",\n      base,\n      expr: obj\n    }), right);\n  },\n  attr_access(p) {\n    const name = p.processString();\n    return right => traversePlain(base => ({\n      type: \"AccessAttribute\",\n      base,\n      name\n    }), right);\n  },\n  deref(p) {\n    let attr = null;\n    if (p.getMark().name === \"deref_attr\") {\n      p.shift();\n      attr = p.processString();\n    }\n    const wrap = base => attr ? {\n      type: \"AccessAttribute\",\n      base,\n      name: attr\n    } : base;\n    return right => traversePlain(base => wrap({\n      type: \"Deref\",\n      base\n    }), right);\n  },\n  array_postfix(p) {\n    return right => traverseArray(base => ({\n      type: \"ArrayCoerce\",\n      base\n    }), right);\n  }\n};\nconst SELECTOR_BUILDER = {\n  group(p) {\n    p.process(SELECTOR_BUILDER);\n    return null;\n  },\n  everything() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  this() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  parent() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  dblparent(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  traverse(p) {\n    p.process(SELECTOR_BUILDER);\n    while (p.getMark().name !== \"traversal_end\") {\n      p.process(TRAVERSE_BUILDER);\n    }\n    p.shift();\n    return null;\n  },\n  this_attr(p) {\n    p.processString();\n    return null;\n  },\n  neg(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pos(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  add(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  sub(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  mul(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  div(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  mod(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pow(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  comp(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  in_range(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  str(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  integer(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  float(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  sci(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  object(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  array(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  tuple(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  func_call(p, mark) {\n    const func = EXPR_BUILDER.func_call(p, mark);\n    if (func.name === \"anywhere\" && func.args.length === 1) return null;\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pipecall(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pair(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  and(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  or(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  not(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  asc(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  desc(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  param(p) {\n    throw new Error(\"Invalid selector syntax\");\n  }\n};\nfunction extractPropertyKey(node) {\n  if (node.type === \"AccessAttribute\" && !node.base) {\n    return node.name;\n  }\n  if (node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\") {\n    return extractPropertyKey(node.base);\n  }\n  throw new GroqQueryError(\"Cannot determine property key for type: \".concat(node.type));\n}\nfunction validateArity(name, arity, count) {\n  if (typeof arity === \"number\") {\n    if (count !== arity) {\n      throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"(). Expected \").concat(arity, \", got \").concat(count, \".\"));\n    }\n  } else if (arity) {\n    if (!arity(count)) {\n      throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"().\"));\n    }\n  }\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n  const functionsRequiringSelectors = [\"changedAny\", \"changedOnly\"];\n  return namespace == \"diff\" && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nclass GroqSyntaxError extends Error {\n  constructor(position) {\n    super(\"Syntax error in GROQ query at position \".concat(position));\n    __publicField(this, \"position\");\n    __publicField(this, \"name\", \"GroqSyntaxError\");\n    this.position = position;\n  }\n}\nfunction parse(input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const result = parse$1(input);\n  if (result.type === \"error\") {\n    throw new GroqSyntaxError(result.position);\n  }\n  const processor = new MarkProcessor(input, result.marks, options);\n  return processor.process(EXPR_BUILDER);\n}\nexports.DateTime = DateTime;\nexports.evaluate = evaluateQuery;\nexports.parse = parse;\n//# sourceMappingURL=1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsSUFBSSxFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEdBQUc7QUFDdEMsZ0RBQWdELEdBQUc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXNhbml0eS1hcHAvLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEuanM/MDQ4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIF9fZGVmUHJvcCQ1ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQ1ID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQ1KG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQ1ID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkNShvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuZnVuY3Rpb24gcGF0aFJlZ0V4cChwYXR0ZXJuKSB7XG4gIGNvbnN0IHJlID0gW107XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXR0ZXJuLnNwbGl0KFwiLlwiKSkge1xuICAgIGlmIChwYXJ0ID09PSBcIipcIikge1xuICAgICAgcmUucHVzaChcIlteLl0rXCIpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gXCIqKlwiKSB7XG4gICAgICByZS5wdXNoKFwiLipcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlLnB1c2goZXNjYXBlUmVnRXhwKHBhcnQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KHJlLmpvaW4oXCIuXCIpLCBcIiRcIikpO1xufVxuY2xhc3MgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDUodGhpcywgXCJwYXR0ZXJuXCIpO1xuICAgIF9fcHVibGljRmllbGQkNSh0aGlzLCBcInBhdHRlcm5SZVwiKTtcbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgIHRoaXMucGF0dGVyblJlID0gcGF0aFJlZ0V4cChwYXR0ZXJuKTtcbiAgfVxuICBtYXRjaGVzKHN0cikge1xuICAgIHJldHVybiB0aGlzLnBhdHRlcm5SZS50ZXN0KHN0cik7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnBhdHRlcm47XG4gIH1cbn1cbnZhciBfX2RlZlByb3AkNCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkNCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkNChvYmosIGtleSwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZVxufSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkNCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDQob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgU3RyZWFtVmFsdWUge1xuICBjb25zdHJ1Y3RvcihnZW5lcmF0b3IpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJ0eXBlXCIsIFwic3RyZWFtXCIpO1xuICAgIF9fcHVibGljRmllbGQkNCh0aGlzLCBcImdlbmVyYXRvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJ0aWNrZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwiaXNEb25lXCIpO1xuICAgIF9fcHVibGljRmllbGQkNCh0aGlzLCBcImRhdGFcIik7XG4gICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgdGhpcy50aWNrZXIgPSBudWxsO1xuICAgIHRoaXMuaXNEb25lID0gZmFsc2U7XG4gICAgdGhpcy5kYXRhID0gW107XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgaXNBcnJheSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBhc3luYyBnZXQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB0aGlzKSB7XG4gICAgICByZXN1bHQucHVzaChhd2FpdCB2YWx1ZS5nZXQoKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBmb3IgKDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB5aWVsZCB0aGlzLmRhdGFbaV07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0RvbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5fbmV4dFRpY2soKTtcbiAgICB9XG4gIH1cbiAgX25leHRUaWNrKCkge1xuICAgIGlmICh0aGlzLnRpY2tlcikge1xuICAgICAgcmV0dXJuIHRoaXMudGlja2VyO1xuICAgIH1cbiAgICBsZXQgY3VycmVudFJlc29sdmVyO1xuICAgIGNvbnN0IHNldHVwVGlja2VyID0gKCkgPT4ge1xuICAgICAgdGhpcy50aWNrZXIgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY3VycmVudFJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdGljayA9ICgpID0+IHtcbiAgICAgIGN1cnJlbnRSZXNvbHZlcigpO1xuICAgICAgc2V0dXBUaWNrZXIoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZldGNoID0gYXN5bmMgKCkgPT4ge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB0aGlzLmdlbmVyYXRvcigpKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKTtcbiAgICAgICAgdGljaygpO1xuICAgICAgfVxuICAgICAgdGhpcy5pc0RvbmUgPSB0cnVlO1xuICAgICAgdGljaygpO1xuICAgIH07XG4gICAgc2V0dXBUaWNrZXIoKTtcbiAgICBmZXRjaCgpO1xuICAgIHJldHVybiB0aGlzLnRpY2tlcjtcbiAgfVxufVxuY29uc3QgUkZDMzMzOV9SRUdFWCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn0oXFwuXFxkKyk/KFp8KFstK11cXGR7Mn06XFxkezJ9KSkkLztcbmZ1bmN0aW9uIHBhcnNlUkZDMzMzOShzdHIpIHtcbiAgaWYgKFJGQzMzMzlfUkVHRVgudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHN0cik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmb3JtYXRSRkMzMzM5KGQpIHtcbiAgY29uc3QgeWVhciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRnVsbFllYXIoKSwgNCk7XG4gIGNvbnN0IG1vbnRoID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNb250aCgpICsgMSwgMik7XG4gIGNvbnN0IGRheSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRGF0ZSgpLCAyKTtcbiAgY29uc3QgaG91ciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDSG91cnMoKSwgMik7XG4gIGNvbnN0IG1pbnV0ZSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTWludXRlcygpLCAyKTtcbiAgY29uc3Qgc2Vjb25kID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENTZWNvbmRzKCksIDIpO1xuICBsZXQgZnJhY3Rpb25hbFNlY29uZCA9IFwiXCI7XG4gIGNvbnN0IG1pbGxpcyA9IGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gIGlmIChtaWxsaXMgIT0gMCkge1xuICAgIGZyYWN0aW9uYWxTZWNvbmQgPSBcIi5cIi5jb25jYXQoYWRkTGVhZGluZ1plcm8obWlsbGlzLCAzKSk7XG4gIH1cbiAgcmV0dXJuIFwiXCIuY29uY2F0KHllYXIsIFwiLVwiKS5jb25jYXQobW9udGgsIFwiLVwiKS5jb25jYXQoZGF5LCBcIlRcIikuY29uY2F0KGhvdXIsIFwiOlwiKS5jb25jYXQobWludXRlLCBcIjpcIikuY29uY2F0KHNlY29uZCkuY29uY2F0KGZyYWN0aW9uYWxTZWNvbmQsIFwiWlwiKTtcbn1cbmZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvKG51bSwgdGFyZ2V0TGVuZ3RoKSB7XG4gIGxldCBzdHIgPSBudW0udG9TdHJpbmcoKTtcbiAgd2hpbGUgKHN0ci5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICBzdHIgPSBcIjBcIi5jb25jYXQoc3RyKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxudmFyIF9fZGVmUHJvcCQzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQzID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQzKG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQzID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkMyhvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBTdGF0aWNWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHR5cGUpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJkYXRhXCIpO1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcInR5cGVcIik7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIGlzQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gXCJhcnJheVwiO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG4gIGFzeW5jIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZGF0YSkge1xuICAgICAgICAgIHlpZWxkIGZyb21KUyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaXRlcmF0ZSBvdmVyOiBcIi5jb25jYXQodGhpcy50eXBlKSk7XG4gIH1cbn1cbmNvbnN0IE5VTExfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUobnVsbCwgXCJudWxsXCIpO1xuY29uc3QgVFJVRV9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZSh0cnVlLCBcImJvb2xlYW5cIik7XG5jb25zdCBGQUxTRV9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZShmYWxzZSwgXCJib29sZWFuXCIpO1xuY2xhc3MgRGF0ZVRpbWUge1xuICBjb25zdHJ1Y3RvcihkYXRlKSB7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwiZGF0ZVwiKTtcbiAgICB0aGlzLmRhdGUgPSBkYXRlO1xuICB9XG4gIHN0YXRpYyBwYXJzZVRvVmFsdWUoc3RyKSB7XG4gICAgY29uc3QgZGF0ZSA9IHBhcnNlUkZDMzMzOShzdHIpO1xuICAgIGlmIChkYXRlKSB7XG4gICAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKG5ldyBEYXRlVGltZShkYXRlKSwgXCJkYXRldGltZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRUaW1lKCkgPT0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgYWRkKHNlY3MpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IERhdGUodGhpcy5kYXRlLmdldFRpbWUoKSk7XG4gICAgY29weS5zZXRUaW1lKGNvcHkuZ2V0VGltZSgpICsgc2VjcyAqIDFlMyk7XG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZShjb3B5KTtcbiAgfVxuICBkaWZmZXJlbmNlKG90aGVyKSB7XG4gICAgcmV0dXJuICh0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCkpIC8gMWUzO1xuICB9XG4gIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdFJGQzMzMzkodGhpcy5kYXRlKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxufVxuZnVuY3Rpb24gZnJvbU51bWJlcihudW0pIHtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShudW0pKSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShudW0sIFwibnVtYmVyXCIpO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufVxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShzdHIsIFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gZnJvbURhdGVUaW1lKGR0KSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoZHQsIFwiZGF0ZXRpbWVcIik7XG59XG5mdW5jdGlvbiBmcm9tUGF0aChwYXRoKSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUocGF0aCwgXCJwYXRoXCIpO1xufVxuZnVuY3Rpb24gaXNJdGVyYXRvcihvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLm5leHQgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGZyb21KUyh2YWwpIHtcbiAgaWYgKGlzSXRlcmF0b3IodmFsKSkge1xuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdmFsKSB7XG4gICAgICAgIHlpZWxkIGZyb21KUyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZSh2YWwsIGdldFR5cGUodmFsKSk7XG59XG5mdW5jdGlvbiBnZXRUeXBlKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwgfHwgdHlwZW9mIGRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICB9XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgUGF0aCkge1xuICAgIHJldHVybiBcInBhdGhcIjtcbiAgfVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIERhdGVUaW1lKSB7XG4gICAgcmV0dXJuIFwiZGF0ZXRpbWVcIjtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGRhdGE7XG59XG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBiLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgYS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBiLnR5cGUgPT09IFwiYm9vbGVhblwiIHx8IGEudHlwZSA9PT0gXCJudWxsXCIgJiYgYi50eXBlID09PSBcIm51bGxcIiB8fCBhLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgYi50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGEuZGF0YSA9PT0gYi5kYXRhO1xuICB9XG4gIGlmIChhLnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiBiLnR5cGUgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgIHJldHVybiBhLmRhdGEuZXF1YWxzKGIuZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgQ0hBUlMgPSAvKFteIUAjJCVeJiooKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZztcbmNvbnN0IENIQVJTX1dJVEhfV0lMRENBUkQgPSAvKFteIUAjJCVeJigpLFxcXFwvP1wiOzp7fXxbXFxdKzw+XFxzLV0pKy9nO1xuY29uc3QgRURHRV9DSEFSUyA9IC8oXFxiXFwuK3xcXC4rXFxiKS9nO1xuY29uc3QgTUFYX1RFUk1fTEVOR1RIID0gMTAyNDtcbmZ1bmN0aW9uIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKSB7XG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHBhdHRlcm5zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcGF0dGVybnMuZXZlcnkocGF0dGVybiA9PiBwYXR0ZXJuKHRva2VucykpO1xufVxuZnVuY3Rpb24gbWF0Y2hUb2tlbml6ZSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UoRURHRV9DSEFSUywgXCJcIikubWF0Y2goQ0hBUlMpIHx8IFtdO1xufVxuZnVuY3Rpb24gbWF0Y2hBbmFseXplUGF0dGVybih0ZXh0KSB7XG4gIGNvbnN0IHRlcm1zUmUgPSBtYXRjaFBhdHRlcm5SZWdleCh0ZXh0KTtcbiAgcmV0dXJuIHRlcm1zUmUubWFwKHJlID0+IHRva2VucyA9PiB0b2tlbnMuc29tZSh0b2tlbiA9PiByZS50ZXN0KHRva2VuKSkpO1xufVxuZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dCkge1xuICBjb25zdCB0ZXJtcyA9IHRleHQucmVwbGFjZShFREdFX0NIQVJTLCBcIlwiKS5tYXRjaChDSEFSU19XSVRIX1dJTERDQVJEKSB8fCBbXTtcbiAgcmV0dXJuIHRlcm1zLm1hcCh0ZXJtID0+IG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KHRlcm0uc2xpY2UoMCwgTUFYX1RFUk1fTEVOR1RIKS5yZXBsYWNlKC9cXCovZywgXCIuKlwiKSwgXCIkXCIpLCBcImlcIikpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2F0aGVyVGV4dCh2YWx1ZSwgY2IpIHtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjYih2YWx1ZS5kYXRhKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgbGV0IHN1Y2Nlc3MgPSB0cnVlO1xuICAgIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiB2YWx1ZSkge1xuICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjYihwYXJ0LmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBUWVBFX09SREVSID0ge1xuICBkYXRldGltZTogMSxcbiAgbnVtYmVyOiAyLFxuICBzdHJpbmc6IDMsXG4gIGJvb2xlYW46IDRcbn07XG5mdW5jdGlvbiBwYXJ0aWFsQ29tcGFyZShhLCBiKSB7XG4gIGNvbnN0IGFUeXBlID0gZ2V0VHlwZShhKTtcbiAgY29uc3QgYlR5cGUgPSBnZXRUeXBlKGIpO1xuICBpZiAoYVR5cGUgIT09IGJUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3dpdGNoIChhVHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgcmV0dXJuIGEuY29tcGFyZVRvKGIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gdG90YWxDb21wYXJlKGEsIGIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRUeXBlKGEpO1xuICBjb25zdCBiVHlwZSA9IGdldFR5cGUoYik7XG4gIGNvbnN0IGFUeXBlT3JkZXIgPSBUWVBFX09SREVSW2FUeXBlXSB8fCAxMDA7XG4gIGNvbnN0IGJUeXBlT3JkZXIgPSBUWVBFX09SREVSW2JUeXBlXSB8fCAxMDA7XG4gIGlmIChhVHlwZU9yZGVyICE9PSBiVHlwZU9yZGVyKSB7XG4gICAgcmV0dXJuIGFUeXBlT3JkZXIgLSBiVHlwZU9yZGVyO1xuICB9XG4gIGxldCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShhLCBiKTtcbiAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgIHJlc3VsdCA9IDA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IG9wZXJhdG9ycyA9IHtcbiAgXCI9PVwiOiBmdW5jdGlvbiBlcShsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCIhPVwiOiBmdW5jdGlvbiBuZXEobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIFwiPlwiOiBmdW5jdGlvbiBndChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA+IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPj1cIjogZnVuY3Rpb24gZ3RlKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0ID49IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPFwiOiBmdW5jdGlvbiBsdChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA8IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPD1cIjogZnVuY3Rpb24gbHRlKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0IDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgaW46IGFzeW5jIGZ1bmN0aW9uIGlub3AobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAocmlnaHQudHlwZSA9PT0gXCJwYXRoXCIpIHtcbiAgICAgIGlmIChsZWZ0LnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmlnaHQuZGF0YS5tYXRjaGVzKGxlZnQuZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIGlmIChyaWdodC5pc0FycmF5KCkpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgYiBvZiByaWdodCkge1xuICAgICAgICBpZiAoaXNFcXVhbChsZWZ0LCBiKSkge1xuICAgICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBtYXRjaDogYXN5bmMgZnVuY3Rpb24gbWF0Y2gobGVmdCwgcmlnaHQpIHtcbiAgICBsZXQgdG9rZW5zID0gW107XG4gICAgbGV0IHBhdHRlcm5zID0gW107XG4gICAgYXdhaXQgZ2F0aGVyVGV4dChsZWZ0LCBwYXJ0ID0+IHtcbiAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShwYXJ0KSk7XG4gICAgfSk7XG4gICAgY29uc3QgZGlkU3VjY2VlZCA9IGF3YWl0IGdhdGhlclRleHQocmlnaHQsIHBhcnQgPT4ge1xuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihwYXJ0KSk7XG4gICAgfSk7XG4gICAgaWYgKCFkaWRTdWNjZWVkKSB7XG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoZWQgPSBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucyk7XG4gICAgcmV0dXJuIG1hdGNoZWQgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiK1wiOiBmdW5jdGlvbiBwbHVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZChyaWdodC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhICsgcmlnaHQuZGF0YSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyaW5nXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZyb21TdHJpbmcobGVmdC5kYXRhICsgcmlnaHQuZGF0YSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwib2JqZWN0XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIGZyb21KUyh7XG4gICAgICAgIC4uLmxlZnQuZGF0YSxcbiAgICAgICAgLi4ucmlnaHQuZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiYXJyYXlcIiAmJiByaWdodC50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgIHJldHVybiBmcm9tSlMobGVmdC5kYXRhLmNvbmNhdChyaWdodC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LmlzQXJyYXkoKSAmJiByaWdodC5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgbGVmdCkge1xuICAgICAgICAgIHlpZWxkIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiByaWdodCkge1xuICAgICAgICAgIHlpZWxkIHZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBcIi1cIjogZnVuY3Rpb24gbWludXMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGZyb21EYXRlVGltZShsZWZ0LmRhdGEuYWRkKC1yaWdodC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YS5kaWZmZXJlbmNlKHJpZ2h0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEgLSByaWdodC5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIFwiKlwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgKiBiKSxcbiAgXCIvXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAvIGIpLFxuICBcIiVcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhICUgYiksXG4gIFwiKipcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBNYXRoLnBvdyhhLCBiKSlcbn07XG5mdW5jdGlvbiBudW1lcmljT3BlcmF0b3IoaW1wbCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBpbXBsKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgICByZXR1cm4gZnJvbU51bWJlcihyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfTtcbn1cbnZhciBfX2RlZlByb3AkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMiA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMihvYmosIGtleSwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZVxufSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMiA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDIob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgU2NvcGUge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuICBjb25zdHJ1Y3RvcihwYXJhbXMsIHNvdXJjZSwgdmFsdWUsIGNvbnRleHQsIHBhcmVudCkge1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcInBhcmFtc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJzb3VyY2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwidmFsdWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwicGFyZW50XCIpO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcImNvbnRleHRcIik7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwiaXNIaWRkZW5cIiwgZmFsc2UpO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG4gIGNyZWF0ZU5lc3RlZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XG4gICAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcy5wYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcyk7XG4gIH1cbiAgY3JlYXRlSGlkZGVuKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIHJlc3VsdC5pc0hpZGRlbiA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuZnVuY3Rpb24gZXZhbHVhdGUobm9kZSwgc2NvcGUpIHtcbiAgbGV0IGV4ZWN1dGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGV2YWx1YXRlO1xuICBjb25zdCBmdW5jID0gRVhFQ1VUT1JTW25vZGUudHlwZV07XG4gIHJldHVybiBmdW5jKG5vZGUsIHNjb3BlLCBleGVjdXRlKTtcbn1cbmZ1bmN0aW9uIHByb21pc2VsZXNzQXBwbHkodmFsdWUsIGNiKSB7XG4gIGlmIChcInRoZW5cIiBpbiB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50aGVuKGNiKTtcbiAgfVxuICByZXR1cm4gY2IodmFsdWUpO1xufVxuY29uc3QgRVhFQ1VUT1JTID0ge1xuICBUaGlzKF8sIHNjb3BlKSB7XG4gICAgcmV0dXJuIHNjb3BlLnZhbHVlO1xuICB9LFxuICBTZWxlY3RvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3RvcnMgY2FuIG5vdCBiZSBldmFsdWF0ZWRcIik7XG4gIH0sXG4gIEV2ZXJ5dGhpbmcoXywgc2NvcGUpIHtcbiAgICByZXR1cm4gc2NvcGUuc291cmNlO1xuICB9LFxuICBQYXJhbWV0ZXIoX3JlZiwgc2NvcGUpIHtcbiAgICBsZXQge1xuICAgICAgbmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBmcm9tSlMoc2NvcGUucGFyYW1zW25hbWVdKTtcbiAgfSxcbiAgQ29udGV4dChfcmVmMiwgc2NvcGUpIHtcbiAgICBsZXQge1xuICAgICAga2V5XG4gICAgfSA9IF9yZWYyO1xuICAgIGlmIChrZXkgPT09IFwiYmVmb3JlXCIgfHwga2V5ID09PSBcImFmdGVyXCIpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc2NvcGUuY29udGV4dFtrZXldO1xuICAgICAgcmV0dXJuIHZhbHVlIHx8IE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gY29udGV4dCBrZXk6IFwiLmNvbmNhdChrZXkpKTtcbiAgfSxcbiAgUGFyZW50KF9yZWYzLCBzY29wZSkge1xuICAgIGxldCB7XG4gICAgICBuXG4gICAgfSA9IF9yZWYzO1xuICAgIGxldCBjdXJyZW50ID0gc2NvcGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGlmICghY3VycmVudC5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICB9LFxuICBPcENhbGwoX3JlZjQsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfSA9IF9yZWY0O1xuICAgIGNvbnN0IGZ1bmMgPSBvcGVyYXRvcnNbb3BdO1xuICAgIGlmICghZnVuYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGVyYXRvcjogXCIuY29uY2F0KG9wKSk7XG4gICAgfVxuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgaWYgKFwidGhlblwiIGluIGxlZnRWYWx1ZSB8fCBcInRoZW5cIiBpbiByaWdodFZhbHVlKSB7XG4gICAgICByZXR1cm4gKGFzeW5jICgpID0+IGZ1bmMoYXdhaXQgbGVmdFZhbHVlLCBhd2FpdCByaWdodFZhbHVlKSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgfSxcbiAgYXN5bmMgU2VsZWN0KF9yZWY1LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBhbHRlcm5hdGl2ZXMsXG4gICAgICBmYWxsYmFja1xuICAgIH0gPSBfcmVmNTtcbiAgICBmb3IgKGNvbnN0IGFsdCBvZiBhbHRlcm5hdGl2ZXMpIHtcbiAgICAgIGNvbnN0IGFsdENvbmQgPSBhd2FpdCBleGVjdXRlKGFsdC5jb25kaXRpb24sIHNjb3BlKTtcbiAgICAgIGlmIChhbHRDb25kLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGFsdENvbmQuZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZXhlY3V0ZShhbHQudmFsdWUsIHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZShmYWxsYmFjaywgc2NvcGUpO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgSW5SYW5nZShfcmVmNiwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZSxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGlzSW5jbHVzaXZlXG4gICAgfSA9IF9yZWY2O1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICBjb25zdCBsZWZ0Q21wID0gcGFydGlhbENvbXBhcmUoYXdhaXQgdmFsdWUuZ2V0KCksIGF3YWl0IGxlZnRWYWx1ZS5nZXQoKSk7XG4gICAgaWYgKGxlZnRDbXAgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCByaWdodENtcCA9IHBhcnRpYWxDb21wYXJlKGF3YWl0IHZhbHVlLmdldCgpLCBhd2FpdCByaWdodFZhbHVlLmdldCgpKTtcbiAgICBpZiAocmlnaHRDbXAgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAoaXNJbmNsdXNpdmUpIHtcbiAgICAgIHJldHVybiBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPD0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnRDbXAgPj0gMCAmJiByaWdodENtcCA8IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEZpbHRlcihfcmVmNywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZSxcbiAgICAgIGV4cHJcbiAgICB9ID0gX3JlZjc7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGJhc2VWYWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChlbGVtKTtcbiAgICAgICAgY29uc3QgZXhwclZhbHVlID0gYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gICAgICAgIGlmIChleHByVmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgZXhwclZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICB5aWVsZCBlbGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGFzeW5jIFByb2plY3Rpb24oX3JlZjgsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBleHByXG4gICAgfSA9IF9yZWY4O1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmIChiYXNlVmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGJhc2VWYWx1ZSk7XG4gICAgcmV0dXJuIGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICB9LFxuICBGdW5jQ2FsbChfcmVmOSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgZnVuYyxcbiAgICAgIGFyZ3NcbiAgICB9ID0gX3JlZjk7XG4gICAgcmV0dXJuIGZ1bmMoYXJncywgc2NvcGUsIGV4ZWN1dGUpO1xuICB9LFxuICBhc3luYyBQaXBlRnVuY0NhbGwoX3JlZjEwLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBmdW5jLFxuICAgICAgYmFzZSxcbiAgICAgIGFyZ3NcbiAgICB9ID0gX3JlZjEwO1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiBmdW5jKGJhc2VWYWx1ZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpO1xuICB9LFxuICBhc3luYyBBY2Nlc3NBdHRyaWJ1dGUoX3JlZjExLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlLFxuICAgICAgbmFtZVxuICAgIH0gPSBfcmVmMTE7XG4gICAgbGV0IHZhbHVlID0gc2NvcGUudmFsdWU7XG4gICAgaWYgKGJhc2UpIHtcbiAgICAgIHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAodmFsdWUuZGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gZnJvbUpTKHZhbHVlLmRhdGFbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQWNjZXNzRWxlbWVudChfcmVmMTIsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBpbmRleFxuICAgIH0gPSBfcmVmMTI7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGJhc2VWYWx1ZS5nZXQoKTtcbiAgICBjb25zdCBmaW5hbEluZGV4ID0gaW5kZXggPCAwID8gaW5kZXggKyBkYXRhLmxlbmd0aCA6IGluZGV4O1xuICAgIHJldHVybiBmcm9tSlMoZGF0YVtmaW5hbEluZGV4XSk7XG4gIH0sXG4gIGFzeW5jIFNsaWNlKF9yZWYxMywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZSxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGlzSW5jbHVzaXZlXG4gICAgfSA9IF9yZWYxMztcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBhcnJheSA9IGF3YWl0IGJhc2VWYWx1ZS5nZXQoKTtcbiAgICBsZXQgbGVmdElkeCA9IGxlZnQ7XG4gICAgbGV0IHJpZ2h0SWR4ID0gcmlnaHQ7XG4gICAgaWYgKGxlZnRJZHggPCAwKSB7XG4gICAgICBsZWZ0SWR4ID0gYXJyYXkubGVuZ3RoICsgbGVmdElkeDtcbiAgICB9XG4gICAgaWYgKHJpZ2h0SWR4IDwgMCkge1xuICAgICAgcmlnaHRJZHggPSBhcnJheS5sZW5ndGggKyByaWdodElkeDtcbiAgICB9XG4gICAgaWYgKGlzSW5jbHVzaXZlKSB7XG4gICAgICByaWdodElkeCsrO1xuICAgIH1cbiAgICBpZiAobGVmdElkeCA8IDApIHtcbiAgICAgIGxlZnRJZHggPSAwO1xuICAgIH1cbiAgICBpZiAocmlnaHRJZHggPCAwKSB7XG4gICAgICByaWdodElkeCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmcm9tSlMoYXJyYXkuc2xpY2UobGVmdElkeCwgcmlnaHRJZHgpKTtcbiAgfSxcbiAgYXN5bmMgRGVyZWYoX3JlZjE0LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlXG4gICAgfSA9IF9yZWYxNDtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghc2NvcGUuc291cmNlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSB2YWx1ZS5kYXRhLl9yZWY7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGlmIChzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKSB7XG4gICAgICByZXR1cm4gZnJvbUpTKGF3YWl0IHNjb3BlLmNvbnRleHQuZGVyZWZlcmVuY2Uoe1xuICAgICAgICBfcmVmOiBpZFxuICAgICAgfSkpO1xuICAgIH1cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBzY29wZS5zb3VyY2UpIHtcbiAgICAgIGlmIChkb2MudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBpZCA9PT0gZG9jLmRhdGEuX2lkKSB7XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBWYWx1ZShfcmVmMTUpIHtcbiAgICBsZXQge1xuICAgICAgdmFsdWVcbiAgICB9ID0gX3JlZjE1O1xuICAgIHJldHVybiBmcm9tSlModmFsdWUpO1xuICB9LFxuICBHcm91cChfcmVmMTYsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2VcbiAgICB9ID0gX3JlZjE2O1xuICAgIHJldHVybiBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgfSxcbiAgYXN5bmMgT2JqZWN0KF9yZWYxNywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYXR0cmlidXRlc1xuICAgIH0gPSBfcmVmMTc7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJUeXBlID0gYXR0ci50eXBlO1xuICAgICAgc3dpdGNoIChhdHRyLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICAgIHJlc3VsdFthdHRyLm5hbWVdID0gYXdhaXQgdmFsdWUuZ2V0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgY29uZCA9IGF3YWl0IGV4ZWN1dGUoYXR0ci5jb25kaXRpb24sIHNjb3BlKTtcbiAgICAgICAgICAgIGlmIChjb25kLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IGNvbmQuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiT2JqZWN0U3BsYXRcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIi5jb25jYXQoYXR0clR5cGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyb21KUyhyZXN1bHQpO1xuICB9LFxuICBBcnJheShfcmVmMTgsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGVsZW1lbnRzXG4gICAgfSA9IF9yZWYxODtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGVsZW1lbnQudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgaWYgKGVsZW1lbnQuaXNTcGxhdCkge1xuICAgICAgICAgIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICB5aWVsZCB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBUdXBsZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXBsZXMgY2FuIG5vdCBiZSBldmFsdWF0ZWRcIik7XG4gIH0sXG4gIGFzeW5jIE9yKF9yZWYxOSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfSA9IF9yZWYxOTtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIGlmIChsZWZ0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmIChsZWZ0VmFsdWUuZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJpZ2h0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmIChyaWdodFZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZWZ0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQW5kKF9yZWYyMCwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfSA9IF9yZWYyMDtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIGlmIChsZWZ0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmIChsZWZ0VmFsdWUuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmlnaHRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgaWYgKHJpZ2h0VmFsdWUuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgTm90KF9yZWYyMSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZVxuICAgIH0gPSBfcmVmMjE7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuZGF0YSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcbiAgfSxcbiAgTmVnKF9yZWYyMiwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZVxuICAgIH0gPSBfcmVmMjI7XG4gICAgcmV0dXJuIHByb21pc2VsZXNzQXBwbHkoZXhlY3V0ZShiYXNlLCBzY29wZSksIHZhbHVlID0+IHtcbiAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLmRhdGEpO1xuICAgIH0pO1xuICB9LFxuICBQb3MoX3JlZjIzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlXG4gICAgfSA9IF9yZWYyMztcbiAgICByZXR1cm4gcHJvbWlzZWxlc3NBcHBseShleGVjdXRlKGJhc2UsIHNjb3BlKSwgdmFsdWUgPT4ge1xuICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbU51bWJlcih2YWx1ZS5kYXRhKTtcbiAgICB9KTtcbiAgfSxcbiAgQXNjKCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBEZXNjKCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBBcnJheUNvZXJjZShfcmVmMjQsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2VcbiAgICB9ID0gX3JlZjI0O1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgcmV0dXJuIHZhbHVlLmlzQXJyYXkoKSA/IHZhbHVlIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgTWFwKF9yZWYyNSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZSxcbiAgICAgIGV4cHJcbiAgICB9ID0gX3JlZjI1O1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCF2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oZWxlbSk7XG4gICAgICAgIHlpZWxkIGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBhc3luYyBGbGF0TWFwKF9yZWYyNiwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZSxcbiAgICAgIGV4cHJcbiAgICB9ID0gX3JlZjI2O1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCF2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oZWxlbSk7XG4gICAgICAgIGNvbnN0IGlubmVyVmFsdWUgPSBhd2FpdCBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgICAgICAgaWYgKGlubmVyVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpbm5lciBvZiBpbm5lclZhbHVlKSB7XG4gICAgICAgICAgICB5aWVsZCBpbm5lcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgaW5uZXJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gZXZhbHVhdGVRdWVyeSh0cmVlKSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgY29uc3Qgcm9vdCA9IGZyb21KUyhvcHRpb25zLnJvb3QpO1xuICBjb25zdCBkYXRhc2V0ID0gZnJvbUpTKG9wdGlvbnMuZGF0YXNldCk7XG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAuLi5vcHRpb25zLnBhcmFtc1xuICB9O1xuICBjb25zdCBzY29wZSA9IG5ldyBTY29wZShwYXJhbXMsIGRhdGFzZXQsIHJvb3QsIHtcbiAgICB0aW1lc3RhbXA6IG9wdGlvbnMudGltZXN0YW1wIHx8IC8qIEBfX1BVUkVfXyAqL25ldyBEYXRlKCksXG4gICAgaWRlbnRpdHk6IG9wdGlvbnMuaWRlbnRpdHkgPT09IHZvaWQgMCA/IFwibWVcIiA6IG9wdGlvbnMuaWRlbnRpdHksXG4gICAgc2FuaXR5OiBvcHRpb25zLnNhbml0eSxcbiAgICBhZnRlcjogb3B0aW9ucy5hZnRlciA/IGZyb21KUyhvcHRpb25zLmFmdGVyKSA6IG51bGwsXG4gICAgYmVmb3JlOiBvcHRpb25zLmJlZm9yZSA/IGZyb21KUyhvcHRpb25zLmJlZm9yZSkgOiBudWxsLFxuICAgIGRlcmVmZXJlbmNlOiBvcHRpb25zLmRlcmVmZXJlbmNlXG4gIH0sIG51bGwpO1xuICByZXR1cm4gZXZhbHVhdGUodHJlZSwgc2NvcGUpO1xufVxuZnVuY3Rpb24gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkdyb3VwXCI6XG4gICAgICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLmJhc2UpO1xuICAgIGNhc2UgXCJWYWx1ZVwiOlxuICAgIGNhc2UgXCJQYXJhbWV0ZXJcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgXCJQb3NcIjpcbiAgICBjYXNlIFwiTmVnXCI6XG4gICAgICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLmJhc2UpO1xuICAgIGNhc2UgXCJPcENhbGxcIjpcbiAgICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICBjYXNlIFwiJVwiOlxuICAgICAgICBjYXNlIFwiKipcIjpcbiAgICAgICAgICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLmxlZnQpICYmIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5yaWdodCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IERVTU1ZX1NDT1BFID0gbmV3IFNjb3BlKHt9LCBOVUxMX1ZBTFVFLCBOVUxMX1ZBTFVFLCB7XG4gIHRpbWVzdGFtcDogLyogQF9fUFVSRV9fICovbmV3IERhdGUoMCksXG4gIGlkZW50aXR5OiBcIm1lXCIsXG4gIGJlZm9yZTogbnVsbCxcbiAgYWZ0ZXI6IG51bGxcbn0sIG51bGwpO1xuZnVuY3Rpb24gdHJ5Q29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIGlmICghY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjb25zdGFudEV2YWx1YXRlKG5vZGUpO1xufVxuZnVuY3Rpb24gY29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIGNvbnN0IHZhbHVlID0gZXZhbHVhdGUobm9kZSwgRFVNTVlfU0NPUEUsIGNvbnN0YW50RXZhbHVhdGUpO1xuICBpZiAoXCJ0aGVuXCIgaW4gdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCVUc6IGNvbnN0YW50IGV2YWx1YXRlIHNob3VsZCBuZXZlciByZXR1cm4gYSBwcm9taXNlXCIpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpIHtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gYmxvY2tUZXh0KHZhbHVlLmRhdGEpO1xuICB9IGVsc2UgaWYgKHZhbHVlLmlzQXJyYXkoKSkge1xuICAgIGNvbnN0IHRleHRzID0gYXdhaXQgYXJyYXlUZXh0KHZhbHVlKTtcbiAgICBpZiAodGV4dHMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRleHRzLmpvaW4oXCJcXG5cXG5cIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuYXN5bmMgZnVuY3Rpb24gYXJyYXlUZXh0KHZhbHVlKSB7XG4gIGxldCByZXN1bHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IGJsb2NrIG9mIHZhbHVlKSB7XG4gICAgaWYgKGJsb2NrLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBibG9ja1RleHQoYmxvY2suZGF0YSk7XG4gICAgICBpZiAodGV4dCAhPT0gbnVsbCkgcmVzdWx0LnB1c2godGV4dCk7XG4gICAgfSBlbHNlIGlmIChibG9jay5pc0FycmF5KCkpIHtcbiAgICAgIGF3YWl0IGFycmF5VGV4dChibG9jaywgcmVzdWx0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGJsb2NrVGV4dChvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmouX3R5cGUgIT09IFwic3RyaW5nXCIpIHJldHVybiBudWxsO1xuICBjb25zdCBjaGlsZHJlbiA9IG9iai5jaGlsZHJlbjtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgcmV0dXJuIG51bGw7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgY2hpbGQuX3R5cGUgPT09IFwic3RyaW5nXCIgJiYgY2hpbGQuX3R5cGUgPT09IFwic3BhblwiICYmIHR5cGVvZiBjaGlsZC50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXN1bHQgKz0gY2hpbGQudGV4dDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IEJNMjVrID0gMS4yO1xuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVTY29yZShub2RlLCBzY29wZSwgZXhlY3V0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSBcIk9wQ2FsbFwiICYmIG5vZGUub3AgPT09IFwibWF0Y2hcIikge1xuICAgIHJldHVybiBldmFsdWF0ZU1hdGNoU2NvcmUobm9kZS5sZWZ0LCBub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJGdW5jQ2FsbFwiICYmIG5vZGUubmFtZSA9PT0gXCJib29zdFwiKSB7XG4gICAgY29uc3QgaW5uZXJTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5hcmdzWzBdLCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgY29uc3QgYm9vc3QgPSBhd2FpdCBleGVjdXRlKG5vZGUuYXJnc1sxXSwgc2NvcGUpO1xuICAgIGlmIChib29zdC50eXBlID09PSBcIm51bWJlclwiICYmIGlubmVyU2NvcmUgPiAwKSB7XG4gICAgICByZXR1cm4gaW5uZXJTY29yZSArIGJvb3N0LmRhdGE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIk9yXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGxlZnRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5sZWZ0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICAgIGNvbnN0IHJpZ2h0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKTtcbiAgICAgICAgcmV0dXJuIGxlZnRTY29yZSArIHJpZ2h0U2NvcmU7XG4gICAgICB9XG4gICAgY2FzZSBcIkFuZFwiOlxuICAgICAge1xuICAgICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgICBjb25zdCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICAgIGlmIChsZWZ0U2NvcmUgPT09IDAgfHwgcmlnaHRTY29yZSA9PT0gMCkgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGV4ZWN1dGUobm9kZSwgc2NvcGUpO1xuICAgICAgICByZXR1cm4gcmVzLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJlcy5kYXRhID09PSB0cnVlID8gMSA6IDA7XG4gICAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlTWF0Y2hTY29yZShsZWZ0LCByaWdodCwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdGV4dCA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICBjb25zdCBwYXR0ZXJuID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICBsZXQgdG9rZW5zID0gW107XG4gIGxldCB0ZXJtcyA9IFtdO1xuICBhd2FpdCBnYXRoZXJUZXh0KHRleHQsIHBhcnQgPT4ge1xuICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShwYXJ0KSk7XG4gIH0pO1xuICBjb25zdCBkaWRTdWNjZWVkID0gYXdhaXQgZ2F0aGVyVGV4dChwYXR0ZXJuLCBwYXJ0ID0+IHtcbiAgICB0ZXJtcyA9IHRlcm1zLmNvbmNhdChtYXRjaFBhdHRlcm5SZWdleChwYXJ0KSk7XG4gIH0pO1xuICBpZiAoIWRpZFN1Y2NlZWQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0ZXJtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgc2NvcmUgPSAwO1xuICBmb3IgKGNvbnN0IHJlIG9mIHRlcm1zKSB7XG4gICAgY29uc3QgZnJlcSA9IHRva2Vucy5yZWR1Y2UoKGMsIHRva2VuKSA9PiBjICsgKHJlLnRlc3QodG9rZW4pID8gMSA6IDApLCAwKTtcbiAgICBzY29yZSArPSBmcmVxICogKEJNMjVrICsgMSkgLyAoZnJlcSArIEJNMjVrKTtcbiAgfVxuICByZXR1cm4gc2NvcmU7XG59XG5mdW5jdGlvbiBoYXNSZWZlcmVuY2UodmFsdWUsIHBhdGhTZXQpIHtcbiAgc3dpdGNoIChnZXRUeXBlKHZhbHVlKSkge1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKHZhbHVlLl9yZWYpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhTZXQuaGFzKHZhbHVlLl9yZWYpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB2IG9mIE9iamVjdC52YWx1ZXModmFsdWUpKSB7XG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY291bnRVVEY4KHN0cikge1xuICBsZXQgY291bnQyID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPj0gNTUyOTYgJiYgY29kZSA8PSA1NjMxOSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvdW50MisrO1xuICB9XG4gIHJldHVybiBjb3VudDI7XG59XG5jb25zdCBfZ2xvYmFsID0ge307XG5fZ2xvYmFsLmFueXdoZXJlID0gYXN5bmMgZnVuY3Rpb24gYW55d2hlcmUoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5fZ2xvYmFsLmFueXdoZXJlLmFyaXR5ID0gMTtcbl9nbG9iYWwuY29hbGVzY2UgPSBhc3luYyBmdW5jdGlvbiBjb2FsZXNjZShhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZywgc2NvcGUpO1xuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bGxcIikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5fZ2xvYmFsLmNvdW50ID0gYXN5bmMgZnVuY3Rpb24gY291bnQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFpbm5lci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbnVtID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCBfIG9mIGlubmVyKSB7XG4gICAgbnVtKys7XG4gIH1cbiAgcmV0dXJuIGZyb21OdW1iZXIobnVtKTtcbn07XG5fZ2xvYmFsLmNvdW50LmFyaXR5ID0gMTtcbl9nbG9iYWwuZGF0ZVRpbWUgPSBhc3luYyBmdW5jdGlvbiBkYXRlVGltZShhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWwgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbC50eXBlID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmICh2YWwudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBEYXRlVGltZS5wYXJzZVRvVmFsdWUodmFsLmRhdGEpO1xufTtcbl9nbG9iYWwuZGF0ZVRpbWUuYXJpdHkgPSAxO1xuX2dsb2JhbC5kZWZpbmVkID0gYXN5bmMgZnVuY3Rpb24gZGVmaW5lZChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICByZXR1cm4gaW5uZXIudHlwZSA9PT0gXCJudWxsXCIgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG59O1xuX2dsb2JhbC5kZWZpbmVkLmFyaXR5ID0gMTtcbl9nbG9iYWwuaWRlbnRpdHkgPSBhc3luYyBmdW5jdGlvbiBpZGVudGl0eShhcmdzLCBzY29wZSkge1xuICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LmlkZW50aXR5KTtcbn07XG5fZ2xvYmFsLmlkZW50aXR5LmFyaXR5ID0gMDtcbl9nbG9iYWwubGVuZ3RoID0gYXN5bmMgZnVuY3Rpb24gbGVuZ3RoKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmIChpbm5lci50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZyb21OdW1iZXIoY291bnRVVEY4KGlubmVyLmRhdGEpKTtcbiAgfVxuICBpZiAoaW5uZXIuaXNBcnJheSgpKSB7XG4gICAgbGV0IG51bSA9IDA7XG4gICAgZm9yIGF3YWl0IChjb25zdCBfIG9mIGlubmVyKSB7XG4gICAgICBudW0rKztcbiAgICB9XG4gICAgcmV0dXJuIGZyb21OdW1iZXIobnVtKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5fZ2xvYmFsLmxlbmd0aC5hcml0eSA9IDE7XG5fZ2xvYmFsLnBhdGggPSBhc3luYyBmdW5jdGlvbiBwYXRoKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmIChpbm5lci50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIGZyb21QYXRoKG5ldyBQYXRoKGlubmVyLmRhdGEpKTtcbn07XG5fZ2xvYmFsLnBhdGguYXJpdHkgPSAxO1xuX2dsb2JhbC5zdHJpbmcgPSBhc3luYyBmdW5jdGlvbiBzdHJpbmcoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJcIi5jb25jYXQodmFsdWUuZGF0YSkpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxufTtcbl9nbG9iYWwuc3RyaW5nLmFyaXR5ID0gMTtcbl9nbG9iYWwucmVmZXJlbmNlcyA9IGFzeW5jIGZ1bmN0aW9uIHJlZmVyZW5jZXMoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgcGF0aFNldCA9IC8qIEBfX1BVUkVfXyAqL25ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGNvbnN0IHBhdGgyID0gYXdhaXQgZXhlY3V0ZShhcmcsIHNjb3BlKTtcbiAgICBpZiAocGF0aDIudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGF0aFNldC5hZGQocGF0aDIuZGF0YSk7XG4gICAgfSBlbHNlIGlmIChwYXRoMi5pc0FycmF5KCkpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBwYXRoMikge1xuICAgICAgICBpZiAoZWxlbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcGF0aFNldC5hZGQoZWxlbS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocGF0aFNldC5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICB9XG4gIGNvbnN0IHNjb3BlVmFsdWUgPSBhd2FpdCBzY29wZS52YWx1ZS5nZXQoKTtcbiAgcmV0dXJuIGhhc1JlZmVyZW5jZShzY29wZVZhbHVlLCBwYXRoU2V0KSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbn07XG5fZ2xvYmFsLnJlZmVyZW5jZXMuYXJpdHkgPSBjID0+IGMgPj0gMTtcbl9nbG9iYWwucm91bmQgPSBhc3luYyBmdW5jdGlvbiByb3VuZChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAodmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGNvbnN0IG51bSA9IHZhbHVlLmRhdGE7XG4gIGxldCBwcmVjID0gMDtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3QgcHJlY1ZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gICAgaWYgKHByZWNWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiIHx8IHByZWNWYWx1ZS5kYXRhIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihwcmVjVmFsdWUuZGF0YSkpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBwcmVjID0gcHJlY1ZhbHVlLmRhdGE7XG4gIH1cbiAgaWYgKHByZWMgPT09IDApIHtcbiAgICBpZiAobnVtIDwgMCkge1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLU1hdGgucm91bmQoLW51bSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbU51bWJlcihNYXRoLnJvdW5kKG51bSkpO1xuICB9XG4gIHJldHVybiBmcm9tTnVtYmVyKE51bWJlcihudW0udG9GaXhlZChwcmVjKSkpO1xufTtcbl9nbG9iYWwucm91bmQuYXJpdHkgPSBjb3VudDIgPT4gY291bnQyID49IDEgJiYgY291bnQyIDw9IDI7XG5fZ2xvYmFsLm5vdyA9IGFzeW5jIGZ1bmN0aW9uIG5vdyhhcmdzLCBzY29wZSkge1xuICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnRpbWVzdGFtcC50b0lTT1N0cmluZygpKTtcbn07XG5fZ2xvYmFsLm5vdy5hcml0eSA9IDA7XG5fZ2xvYmFsLmJvb3N0ID0gYXN5bmMgZnVuY3Rpb24gYm9vc3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgYm9vc3QgY2FsbFwiKTtcbn07XG5fZ2xvYmFsLmJvb3N0LmFyaXR5ID0gMjtcbmNvbnN0IHN0cmluZzIgPSB7fTtcbnN0cmluZzIubG93ZXIgPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvTG93ZXJDYXNlKCkpO1xufTtcbnN0cmluZzIubG93ZXIuYXJpdHkgPSAxO1xuc3RyaW5nMi51cHBlciA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAodmFsdWUudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9VcHBlckNhc2UoKSk7XG59O1xuc3RyaW5nMi51cHBlci5hcml0eSA9IDE7XG5zdHJpbmcyLnNwbGl0ID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHN0ciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoc3RyLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBjb25zdCBzZXAgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcbiAgaWYgKHNlcC50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgaWYgKHN0ci5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmcm9tSlMoW10pO1xuICB9XG4gIGlmIChzZXAuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnJvbUpTKEFycmF5LmZyb20oc3RyLmRhdGEpKTtcbiAgfVxuICByZXR1cm4gZnJvbUpTKHN0ci5kYXRhLnNwbGl0KHNlcC5kYXRhKSk7XG59O1xuc3RyaW5nMi5zcGxpdC5hcml0eSA9IDI7XG5fZ2xvYmFsLmxvd2VyID0gc3RyaW5nMi5sb3dlcjtcbl9nbG9iYWwudXBwZXIgPSBzdHJpbmcyLnVwcGVyO1xuc3RyaW5nMi5zdGFydHNXaXRoID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHN0ciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoc3RyLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcbiAgaWYgKHByZWZpeC50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIHN0ci5kYXRhLnN0YXJ0c1dpdGgocHJlZml4LmRhdGEpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xufTtcbnN0cmluZzIuc3RhcnRzV2l0aC5hcml0eSA9IDI7XG5jb25zdCBhcnJheSA9IHt9O1xuYXJyYXkuam9pbiA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBhcnIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFhcnIuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3Qgc2VwID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gIGlmIChzZXAudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGxldCBidWYgPSBcIlwiO1xuICBsZXQgbmVlZFNlcCA9IGZhbHNlO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKSB7XG4gICAgaWYgKG5lZWRTZXApIHtcbiAgICAgIGJ1ZiArPSBzZXAuZGF0YTtcbiAgICB9XG4gICAgc3dpdGNoIChlbGVtLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgICAgYnVmICs9IFwiXCIuY29uY2F0KGVsZW0uZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIG5lZWRTZXAgPSB0cnVlO1xuICB9XG4gIHJldHVybiBmcm9tSlMoYnVmKTtcbn07XG5hcnJheS5qb2luLmFyaXR5ID0gMjtcbmFycmF5LmNvbXBhY3QgPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKSB7XG4gICAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bGxcIikge1xuICAgICAgICB5aWVsZCBlbGVtO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuYXJyYXkuY29tcGFjdC5hcml0eSA9IDE7XG5hcnJheS51bmlxdWUgPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCF2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYWRkZWQgPSAvKiBAX19QVVJFX18gKi9uZXcgU2V0KCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVyIG9mIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKGl0ZXIudHlwZSkge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICAgICAgaWYgKCFhZGRlZC5oYXMoaXRlci5kYXRhKSkge1xuICAgICAgICAgICAgYWRkZWQuYWRkKGl0ZXIuZGF0YSk7XG4gICAgICAgICAgICB5aWVsZCBpdGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB5aWVsZCBpdGVyO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuYXJyYXkudW5pcXVlLmFyaXR5ID0gMTtcbmNvbnN0IHB0ID0ge307XG5wdC50ZXh0ID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGNvbnN0IHRleHQgPSBhd2FpdCBwb3J0YWJsZVRleHRDb250ZW50KHZhbHVlKTtcbiAgaWYgKHRleHQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbVN0cmluZyh0ZXh0KTtcbn07XG5wdC50ZXh0LmFyaXR5ID0gMTtcbmNvbnN0IHNhbml0eSA9IHt9O1xuc2FuaXR5LnByb2plY3RJZCA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSkge1xuICBpZiAoc2NvcGUuY29udGV4dC5zYW5pdHkpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnNhbml0eS5wcm9qZWN0SWQpO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbnNhbml0eS5kYXRhc2V0ID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlKSB7XG4gIGlmIChzY29wZS5jb250ZXh0LnNhbml0eSkge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LmRhdGFzZXQpO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbmNvbnN0IHBpcGVGdW5jdGlvbnMgPSB7fTtcbnBpcGVGdW5jdGlvbnMub3JkZXIgPSBhc3luYyBmdW5jdGlvbiBvcmRlcihiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBhd2FpdCB0cnVlO1xuICBpZiAoIWJhc2UuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3QgbWFwcGVycyA9IFtdO1xuICBjb25zdCBkaXJlY3Rpb25zID0gW107XG4gIGxldCBuID0gMDtcbiAgZm9yIChsZXQgbWFwcGVyIG9mIGFyZ3MpIHtcbiAgICBsZXQgZGlyZWN0aW9uID0gXCJhc2NcIjtcbiAgICBpZiAobWFwcGVyLnR5cGUgPT09IFwiRGVzY1wiKSB7XG4gICAgICBkaXJlY3Rpb24gPSBcImRlc2NcIjtcbiAgICAgIG1hcHBlciA9IG1hcHBlci5iYXNlO1xuICAgIH0gZWxzZSBpZiAobWFwcGVyLnR5cGUgPT09IFwiQXNjXCIpIHtcbiAgICAgIG1hcHBlciA9IG1hcHBlci5iYXNlO1xuICAgIH1cbiAgICBtYXBwZXJzLnB1c2gobWFwcGVyKTtcbiAgICBkaXJlY3Rpb25zLnB1c2goZGlyZWN0aW9uKTtcbiAgICBuKys7XG4gIH1cbiAgY29uc3QgYXV4ID0gW107XG4gIGxldCBpZHggPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJhc2UpIHtcbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgY29uc3QgdHVwbGUgPSBbYXdhaXQgdmFsdWUuZ2V0KCksIGlkeF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGUobWFwcGVyc1tpXSwgbmV3U2NvcGUpO1xuICAgICAgdHVwbGUucHVzaChhd2FpdCByZXN1bHQuZ2V0KCkpO1xuICAgIH1cbiAgICBhdXgucHVzaCh0dXBsZSk7XG4gICAgaWR4Kys7XG4gIH1cbiAgYXV4LnNvcnQoKGFUdXBsZSwgYlR1cGxlKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGxldCBjID0gdG90YWxDb21wYXJlKGFUdXBsZVtpICsgMl0sIGJUdXBsZVtpICsgMl0pO1xuICAgICAgaWYgKGRpcmVjdGlvbnNbaV0gPT09IFwiZGVzY1wiKSB7XG4gICAgICAgIGMgPSAtYztcbiAgICAgIH1cbiAgICAgIGlmIChjICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYVR1cGxlWzFdIC0gYlR1cGxlWzFdO1xuICB9KTtcbiAgcmV0dXJuIGZyb21KUyhhdXgubWFwKHYgPT4gdlswXSkpO1xufTtcbnBpcGVGdW5jdGlvbnMub3JkZXIuYXJpdHkgPSBjb3VudDIgPT4gY291bnQyID49IDE7XG5waXBlRnVuY3Rpb25zLnNjb3JlID0gYXN5bmMgZnVuY3Rpb24gc2NvcmUoYmFzZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKCFiYXNlLmlzQXJyYXkoKSkgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHVua25vd24gPSBbXTtcbiAgY29uc3Qgc2NvcmVkID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYmFzZSkge1xuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB1bmtub3duLnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICBsZXQgdmFsdWVTY29yZSA9IHR5cGVvZiB2YWx1ZS5kYXRhLl9zY29yZSA9PT0gXCJudW1iZXJcIiA/IHZhbHVlLmRhdGEuX3Njb3JlIDogMDtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICB2YWx1ZVNjb3JlICs9IGF3YWl0IGV2YWx1YXRlU2NvcmUoYXJnLCBuZXdTY29wZSwgZXhlY3V0ZSk7XG4gICAgfVxuICAgIGNvbnN0IG5ld09iamVjdCA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlLmRhdGEsIHtcbiAgICAgIF9zY29yZTogdmFsdWVTY29yZVxuICAgIH0pO1xuICAgIHNjb3JlZC5wdXNoKG5ld09iamVjdCk7XG4gIH1cbiAgc2NvcmVkLnNvcnQoKGEsIGIpID0+IGIuX3Njb3JlIC0gYS5fc2NvcmUpO1xuICByZXR1cm4gZnJvbUpTKHNjb3JlZCk7XG59O1xucGlwZUZ1bmN0aW9ucy5zY29yZS5hcml0eSA9IGNvdW50MiA9PiBjb3VudDIgPj0gMTtcbmNvbnN0IGRlbHRhID0ge307XG5kZWx0YS5vcGVyYXRpb24gPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUpIHtcbiAgY29uc3QgaGFzQmVmb3JlID0gc2NvcGUuY29udGV4dC5iZWZvcmUgIT09IG51bGw7XG4gIGNvbnN0IGhhc0FmdGVyID0gc2NvcGUuY29udGV4dC5hZnRlciAhPT0gbnVsbDtcbiAgaWYgKGhhc0JlZm9yZSAmJiBoYXNBZnRlcikge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKFwidXBkYXRlXCIpO1xuICB9XG4gIGlmIChoYXNBZnRlcikge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKFwiY3JlYXRlXCIpO1xuICB9XG4gIGlmIChoYXNCZWZvcmUpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcImRlbGV0ZVwiKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5kZWx0YS5jaGFuZ2VkQW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGVsdGEuY2hhbmdlZEFueS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkQW55Lm1vZGUgPSBcImRlbHRhXCI7XG5kZWx0YS5jaGFuZ2VkT25seSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRlbHRhLmNoYW5nZWRPbmx5LmFyaXR5ID0gMTtcbmRlbHRhLmNoYW5nZWRPbmx5Lm1vZGUgPSBcImRlbHRhXCI7XG5jb25zdCBkaWZmID0ge307XG5kaWZmLmNoYW5nZWRBbnkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kaWZmLmNoYW5nZWRBbnkuYXJpdHkgPSAzO1xuZGlmZi5jaGFuZ2VkT25seSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRpZmYuY2hhbmdlZE9ubHkuYXJpdHkgPSAzO1xuY29uc3QgbWF0aCA9IHt9O1xubWF0aC5taW4gPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGxldCBuO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKSB7XG4gICAgaWYgKGVsZW0udHlwZSA9PT0gXCJudWxsXCIpIGNvbnRpbnVlO1xuICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAobiA9PT0gdm9pZCAwIHx8IGVsZW0uZGF0YSA8IG4pIHtcbiAgICAgIG4gPSBlbGVtLmRhdGE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcm9tSlMobik7XG59O1xubWF0aC5taW4uYXJpdHkgPSAxO1xubWF0aC5tYXggPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGxldCBuO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKSB7XG4gICAgaWYgKGVsZW0udHlwZSA9PT0gXCJudWxsXCIpIGNvbnRpbnVlO1xuICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAobiA9PT0gdm9pZCAwIHx8IGVsZW0uZGF0YSA+IG4pIHtcbiAgICAgIG4gPSBlbGVtLmRhdGE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcm9tSlMobik7XG59O1xubWF0aC5tYXguYXJpdHkgPSAxO1xubWF0aC5zdW0gPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGxldCBuID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIGlmIChlbGVtLnR5cGUgPT09IFwibnVsbFwiKSBjb250aW51ZTtcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgbiArPSBlbGVtLmRhdGE7XG4gIH1cbiAgcmV0dXJuIGZyb21KUyhuKTtcbn07XG5tYXRoLnN1bS5hcml0eSA9IDE7XG5tYXRoLmF2ZyA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBhcnIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFhcnIuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgbGV0IG4gPSAwO1xuICBsZXQgYyA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpIHtcbiAgICBpZiAoZWxlbS50eXBlID09PSBcIm51bGxcIikgY29udGludWU7XG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIG4gKz0gZWxlbS5kYXRhO1xuICAgIGMrKztcbiAgfVxuICBpZiAoYyA9PT0gMCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBmcm9tSlMobiAvIGMpO1xufTtcbm1hdGguYXZnLmFyaXR5ID0gMTtcbmNvbnN0IGRhdGVUaW1lMiA9IHt9O1xuZGF0ZVRpbWUyLm5vdyA9IGFzeW5jIGZ1bmN0aW9uIG5vdzIoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgcmV0dXJuIGZyb21EYXRlVGltZShuZXcgRGF0ZVRpbWUoc2NvcGUuY29udGV4dC50aW1lc3RhbXApKTtcbn07XG5kYXRlVGltZTIubm93LmFyaXR5ID0gMDtcbmNvbnN0IG5hbWVzcGFjZXMgPSB7XG4gIGdsb2JhbDogX2dsb2JhbCxcbiAgc3RyaW5nOiBzdHJpbmcyLFxuICBhcnJheSxcbiAgcHQsXG4gIGRlbHRhLFxuICBkaWZmLFxuICBzYW5pdHksXG4gIG1hdGgsXG4gIGRhdGVUaW1lOiBkYXRlVGltZTJcbn07XG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQxKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIE1hcmtQcm9jZXNzb3Ige1xuICBjb25zdHJ1Y3RvcihzdHJpbmcsIG1hcmtzLCBwYXJzZU9wdGlvbnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJzdHJpbmdcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibWFya3NcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaW5kZXhcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicGFyc2VPcHRpb25zXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImFsbG93Qm9vc3RcIiwgZmFsc2UpO1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLnBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9ucztcbiAgfVxuICBoYXNNYXJrKCkge1xuICAgIGxldCBwb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXggKyBwb3MgPCB0aGlzLm1hcmtzLmxlbmd0aDtcbiAgfVxuICBnZXRNYXJrKCkge1xuICAgIGxldCBwb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgcmV0dXJuIHRoaXMubWFya3NbdGhpcy5pbmRleCArIHBvc107XG4gIH1cbiAgc2hpZnQoKSB7XG4gICAgdGhpcy5pbmRleCArPSAxO1xuICB9XG4gIHByb2Nlc3ModmlzaXRvcikge1xuICAgIGNvbnN0IG1hcmsgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgIHRoaXMuc2hpZnQoKTtcbiAgICBjb25zdCBmdW5jID0gdmlzaXRvclttYXJrLm5hbWVdO1xuICAgIGlmICghZnVuYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBoYW5kbGVyOiBcIi5jb25jYXQobWFyay5uYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmNhbGwodmlzaXRvciwgdGhpcywgbWFyayk7XG4gIH1cbiAgcHJvY2Vzc1N0cmluZygpIHtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICB9XG4gIHByb2Nlc3NTdHJpbmdFbmQoKSB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMubWFya3NbdGhpcy5pbmRleCAtIDFdO1xuICAgIGNvbnN0IGN1cnIgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgIHRoaXMuc2hpZnQoKTtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocHJldi5wb3NpdGlvbiwgY3Vyci5wb3NpdGlvbik7XG4gIH1cbiAgc2xpY2UobGVuKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XS5wb3NpdGlvbjtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocG9zLCBwb3MgKyBsZW4pO1xuICB9XG59XG5jb25zdCBXUyA9IC9eKFtcXHRcXG5cXHZcXGZcXHIgXFx1MDA4NVxcdTAwQTBdfChcXC9cXC9bXlxcbl0qXFxuKSkrLztcbmNvbnN0IE5VTSA9IC9eXFxkKy87XG5jb25zdCBJREVOVCA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKi87XG5jb25zdCBQUkVDX1BBSVIgPSAxO1xuY29uc3QgUFJFQ19PUiA9IDI7XG5jb25zdCBQUkVDX0FORCA9IDM7XG5jb25zdCBQUkVDX0NPTVAgPSA0O1xuY29uc3QgUFJFQ19PUkRFUiA9IDQ7XG5jb25zdCBQUkVDX0FERCA9IDY7XG5jb25zdCBQUkVDX1NVQiA9IDY7XG5jb25zdCBQUkVDX01VTCA9IDc7XG5jb25zdCBQUkVDX0RJViA9IDc7XG5jb25zdCBQUkVDX01PRCA9IDc7XG5jb25zdCBQUkVDX1BPVyA9IDg7XG5jb25zdCBQUkVDX1BPUyA9IDEwO1xuY29uc3QgUFJFQ19OT1QgPSAxMDtcbmNvbnN0IFBSRUNfTkVHID0gODtcbmZ1bmN0aW9uIHBhcnNlJDEoc3RyKSB7XG4gIGxldCBwb3MgPSAwO1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XG4gIGlmIChwb3MgIT09IHN0ci5sZW5ndGgpIHtcbiAgICBpZiAocmVzdWx0LmZhaWxQb3NpdGlvbikge1xuICAgICAgcG9zID0gcmVzdWx0LmZhaWxQb3NpdGlvbiAtIDE7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICBwb3NpdGlvbjogcG9zXG4gICAgfTtcbiAgfVxuICBkZWxldGUgcmVzdWx0LnBvc2l0aW9uO1xuICBkZWxldGUgcmVzdWx0LmZhaWxQb3NpdGlvbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHIsIHBvcywgbGV2ZWwpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xuICBsZXQgdG9rZW4gPSBzdHJbcG9zXTtcbiAgbGV0IG1hcmtzO1xuICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgY2FzZSBcIitcIjpcbiAgICAgIHtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCBQUkVDX1BPUyk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcyA9IFt7XG4gICAgICAgICAgbmFtZTogXCJwb3NcIixcbiAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBcIi1cIjpcbiAgICAgIHtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCBQUkVDX05FRyk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcyA9IFt7XG4gICAgICAgICAgbmFtZTogXCJuZWdcIixcbiAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBcIihcIjpcbiAgICAgIHtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCAwKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbik7XG4gICAgICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtYXJrcyA9IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIsXCIpIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidHVwbGVfZW5kXCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIilcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIG1hcmtzID0gW3tcbiAgICAgICAgICAgICAgICBuYW1lOiBcImdyb3VwXCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgIH1dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCIhXCI6XG4gICAgICB7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19OT1QpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgIG5hbWU6IFwibm90XCIsXG4gICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgIH1dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJ7XCI6XG4gICAgICB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwiW1wiOlxuICAgICAgbWFya3MgPSBbe1xuICAgICAgICBuYW1lOiBcImFycmF5XCIsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgIH1dO1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwiXVwiKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKHN0ci5zbGljZShwb3MsIHBvcyArIDMpID09PSBcIi4uLlwiKSB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgbmFtZTogXCJhcnJheV9zcGxhdFwiLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcmVzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgICBpZiAocmVzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlcztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXMubWFya3MpO1xuICAgICAgICAgIHBvcyA9IHJlcy5wb3NpdGlvbjtcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIsXCIpIGJyZWFrO1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJdXCIpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBcImFycmF5X2VuZFwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJ1wiOlxuICAgIGNhc2UgJ1wiJzpcbiAgICAgIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlU3RyaW5nKHN0ciwgcG9zKTtcbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzO1xuICAgICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJeXCI6XG4gICAgICB7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBtYXJrcyA9IFtdO1xuICAgICAgICB3aGlsZSAoc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCJeXCIpIHtcbiAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZGJscGFyZW50XCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBcInBhcmVudFwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBcIkBcIjpcbiAgICAgIG1hcmtzID0gW3tcbiAgICAgICAgbmFtZTogXCJ0aGlzXCIsXG4gICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgfV07XG4gICAgICBwb3MrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIqXCI6XG4gICAgICBtYXJrcyA9IFt7XG4gICAgICAgIG5hbWU6IFwiZXZlcnl0aGluZ1wiLFxuICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgIH1dO1xuICAgICAgcG9zKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJFwiOlxuICAgICAge1xuICAgICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zICsgMSwgSURFTlQpO1xuICAgICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgICBwb3MgKz0gMSArIGlkZW50TGVuO1xuICAgICAgICAgIG1hcmtzID0gW3tcbiAgICAgICAgICAgIG5hbWU6IFwicGFyYW1cIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiaWRlbnRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvcyArIDFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImlkZW50X2VuZFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGxldCBudW1MZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBOVU0pO1xuICAgICAgICBpZiAobnVtTGVuKSB7XG4gICAgICAgICAgcG9zICs9IG51bUxlbjtcbiAgICAgICAgICBsZXQgbmFtZSA9IFwiaW50ZWdlclwiO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgIGxldCBmcmFjTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIE5VTSk7XG4gICAgICAgICAgICBpZiAoZnJhY0xlbikge1xuICAgICAgICAgICAgICBuYW1lID0gXCJmbG9hdFwiO1xuICAgICAgICAgICAgICBwb3MgKz0gMSArIGZyYWNMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJlXCIgfHwgc3RyW3Bvc10gPT09IFwiRVwiKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJzY2lcIjtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIitcIiB8fCBzdHJbcG9zXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXhwTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgICAgICAgIGlmICghZXhwTGVuKSByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3MgKz0gZXhwTGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXJrcyA9IFt7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogbmFtZSArIFwiX2VuZFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgIH1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgICAgcG9zICs9IGlkZW50TGVuO1xuICAgICAgICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICAgICAgICAgIGNhc2UgXCI6XCI6XG4gICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXJrcyA9IFt7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcInRoaXNfYXR0clwiLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJpZGVudFwiLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJpZGVudF9lbmRcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG4gIGlmICghbWFya3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgcG9zaXRpb246IHBvc1xuICAgIH07XG4gIH1cbiAgbGV0IGxoc0xldmVsID0gMTI7XG4gIGxldCB0cmF2O1xuICBsb29wOiB3aGlsZSAodHJ1ZSkge1xuICAgIGxldCBpbm5lclBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgaWYgKGlubmVyUG9zID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICBwb3MgPSBpbm5lclBvcztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBpbm5lclBvcyk7XG4gICAgaWYgKHRyYXYudHlwZSA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICBuYW1lOiBcInRyYXZlcnNlXCIsXG4gICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgfSk7XG4gICAgICB3aGlsZSAodHJhdi50eXBlID09PSBcInN1Y2Nlc3NcIikge1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh0cmF2Lm1hcmtzKTtcbiAgICAgICAgcG9zID0gdHJhdi5wb3NpdGlvbjtcbiAgICAgICAgdHJhdiA9IHBhcnNlVHJhdmVyc2FsKHN0ciwgc2tpcFdTKHN0ciwgcG9zKSk7XG4gICAgICB9XG4gICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgbmFtZTogXCJ0cmF2ZXJzYWxfZW5kXCIsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCB0b2tlbjIgPSBzdHJbaW5uZXJQb3NdO1xuICAgIHN3aXRjaCAodG9rZW4yKSB7XG4gICAgICBjYXNlIFwiPVwiOlxuICAgICAgICB7XG4gICAgICAgICAgbGV0IG5leHRUb2tlbiA9IHN0cltpbm5lclBvcyArIDFdO1xuICAgICAgICAgIHN3aXRjaCAobmV4dFRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19QQUlSIHx8IGxoc0xldmVsIDw9IFBSRUNfUEFJUikgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QQUlSKTtcbiAgICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJwYWlyXCIsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX1BBSVI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKSBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiY29tcFwiLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIm9wXCIsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaW5uZXJQb3NcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIm9wX2VuZFwiLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGlubmVyUG9zICsgMlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQUREIHx8IGxoc0xldmVsIDwgUFJFQ19BREQpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfQUREICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWRkXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0FERDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfU1VCIHx8IGxoc0xldmVsIDwgUFJFQ19TVUIpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfU1VCICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgIG5hbWU6IFwic3ViXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX1NVQjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfUE9XIHx8IGxoc0xldmVsIDw9IFBSRUNfUE9XKSBicmVhayBsb29wO1xuICAgICAgICAgICAgbGV0IHJoczIgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX1BPVyk7XG4gICAgICAgICAgICBpZiAocmhzMi50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHMyO1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzMi5tYXJrcyk7XG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgbmFtZTogXCJwb3dcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvcyA9IHJoczIucG9zaXRpb247XG4gICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfUE9XO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfTVVMIHx8IGxoc0xldmVsIDwgUFJFQ19NVUwpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfTVVMICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgIG5hbWU6IFwibXVsXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX01VTDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfRElWIHx8IGxoc0xldmVsIDwgUFJFQ19ESVYpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfRElWICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgIG5hbWU6IFwiZGl2XCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0RJVjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfTU9EIHx8IGxoc0xldmVsIDwgUFJFQ19NT0QpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfTU9EICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgIG5hbWU6IFwibW9kXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX01PRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIjxcIjpcbiAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCBuZXh0UG9zID0gaW5uZXJQb3MgKyAxO1xuICAgICAgICAgIGlmIChzdHJbbmV4dFBvc10gPT09IFwiPVwiKSB7XG4gICAgICAgICAgICBuZXh0UG9zKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zKSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcImNvbXBcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJvcFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IGlubmVyUG9zXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJvcF9lbmRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXh0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJ8XCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwifFwiKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SIHx8IGxoc0xldmVsIDwgUFJFQ19PUikgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX09SICsgMSk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgbmFtZTogXCJvclwiLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiAxMSB8fCBsaHNMZXZlbCA8IDExKSBicmVhayBsb29wO1xuICAgICAgICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKTtcbiAgICAgICAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBpZGVudFBvcywgSURFTlQpO1xuICAgICAgICAgICAgaWYgKCFpZGVudExlbikgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogaWRlbnRQb3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuO1xuICAgICAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIihcIiB8fCBzdHJbcG9zXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBpZGVudFBvcywgcG9zKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwicGlwZWNhbGxcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSAxMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCImXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gIT0gXCImXCIpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19BTkQgfHwgbGhzTGV2ZWwgPCBQUkVDX0FORCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19BTkQgKyAxKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgbmFtZTogXCJhbmRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQU5EO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiIVwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9PSBcIj1cIikgYnJlYWsgbG9vcDtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgIG5hbWU6IFwiY29tcFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcIm9wXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogaW5uZXJQb3NcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcIm9wX2VuZFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IGlubmVyUG9zICsgMlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiZFwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyA0KSAhPT0gXCJkZXNjXCIpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUkRFUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1JERVIpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcImRlc2NcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvcyA9IGlubmVyUG9zICsgNDtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfT1JERVI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoc3RyLnNsaWNlKGlubmVyUG9zLCBpbm5lclBvcyArIDMpICE9PSBcImFzY1wiKSBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfT1JERVIgfHwgbGhzTGV2ZWwgPCBQUkVDX09SREVSKSBicmVhayBsb29wO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgbmFtZTogXCJhc2NcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvcyA9IGlubmVyUG9zICsgMztcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfT1JERVI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBsZXQgaWRlbnQgPSBwYXJzZVJlZ2V4U3RyKHN0ciwgaW5uZXJQb3MsIElERU5UKTtcbiAgICAgICAgICBzd2l0Y2ggKGlkZW50KSB7XG4gICAgICAgICAgICBjYXNlIFwiaW5cIjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKTtcbiAgICAgICAgICAgICAgICBsZXQgaXNHcm91cCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgIGlzR3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByYW5nZVBvcyA9IHBvcztcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBcImluY19yYW5nZVwiO1xuICAgICAgICAgICAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwiZXhjX3JhbmdlXCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaW5fcmFuZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHJhbmdlUG9zXG4gICAgICAgICAgICAgICAgICB9LCByZXN1bHQubWFya3MsIHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImNvbXBcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm9wXCIsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpbm5lclBvc1xuICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm9wX2VuZFwiLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaW5uZXJQb3MgKyAyXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICAgICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIilcIikgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwibWF0Y2hcIjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgNSksIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJjb21wXCIsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwib3BcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpbm5lclBvc1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwib3BfZW5kXCIsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaW5uZXJQb3MgKyA1XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICAgICAgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgZmFpbFBvc2l0aW9uID0gKHRyYXYgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYXYudHlwZSkgPT09IFwiZXJyb3JcIiAmJiB0cmF2LnBvc2l0aW9uO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgIG1hcmtzLFxuICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgZmFpbFBvc2l0aW9uXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVRyYXZlcnNhbChzdHIsIHBvcykge1xuICBsZXQgc3RhcnRQb3MgPSBwb3M7XG4gIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICBjYXNlIFwiLlwiOlxuICAgICAge1xuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgbGV0IGlkZW50U3RhcnQgPSBwb3M7XG4gICAgICAgIGxldCBpZGVudExlbjIgPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICAgIGlmICghaWRlbnRMZW4yKSByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgIH07XG4gICAgICAgIHBvcyArPSBpZGVudExlbjI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWFya3M6IFt7XG4gICAgICAgICAgICBuYW1lOiBcImF0dHJfYWNjZXNzXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImlkZW50XCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogaWRlbnRTdGFydFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiaWRlbnRfZW5kXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgXCItXCI6XG4gICAgICBpZiAoc3RyW3BvcyArIDFdICE9PSBcIj5cIikgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9O1xuICAgICAgbGV0IG1hcmtzID0gW3tcbiAgICAgICAgbmFtZTogXCJkZXJlZlwiLFxuICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgIH1dO1xuICAgICAgcG9zICs9IDI7XG4gICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIGlkZW50UG9zLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgcG9zID0gaWRlbnRQb3MgKyBpZGVudExlbjtcbiAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgbmFtZTogXCJkZXJlZl9hdHRyXCIsXG4gICAgICAgICAgcG9zaXRpb246IGlkZW50UG9zXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImlkZW50XCIsXG4gICAgICAgICAgcG9zaXRpb246IGlkZW50UG9zXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImlkZW50X2VuZFwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3MsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgIH07XG4gICAgY2FzZSBcIltcIjpcbiAgICAgIHtcbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJdXCIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICBtYXJrczogW3tcbiAgICAgICAgICAgICAgbmFtZTogXCJhcnJheV9wb3N0Zml4XCIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhbmdlUG9zID0gcG9zO1xuICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgICAgICBpZiAoc3RyW3BvcyArIDJdID09PSBcIi5cIikge1xuICAgICAgICAgICAgdHlwZSA9IFwiZXhjX3JhbmdlXCI7XG4gICAgICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiXVwiKSByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgbWFya3M6IFt7XG4gICAgICAgICAgICAgIG5hbWU6IFwic2xpY2VcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIG5hbWU6IHR5cGUsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiByYW5nZVBvc1xuICAgICAgICAgICAgfV0uY29uY2F0KHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiXVwiKSByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWFya3M6IFt7XG4gICAgICAgICAgICBuYW1lOiBcInNxdWFyZV9icmFja2V0XCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9XS5jb25jYXQocmVzdWx0Lm1hcmtzKSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgXCJ8XCI6XG4gICAgICB7XG4gICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwie1wiKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICByZXN1bHQubWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcInByb2plY3Rpb25cIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBcIntcIjpcbiAgICAgIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHJlc3VsdC5tYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICBuYW1lOiBcInByb2plY3Rpb25cIixcbiAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgcG9zaXRpb246IHBvc1xuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VGdW5jQ2FsbChzdHIsIHN0YXJ0UG9zLCBwb3MpIHtcbiAgbGV0IG1hcmtzID0gW107XG4gIG1hcmtzLnB1c2goe1xuICAgIG5hbWU6IFwiZnVuY19jYWxsXCIsXG4gICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gIH0pO1xuICBpZiAoc3RyW3Bvc10gPT09IFwiOlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCI6XCIpIHtcbiAgICBtYXJrcy5wdXNoKHtcbiAgICAgIG5hbWU6IFwibmFtZXNwYWNlXCIsXG4gICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICB9KTtcbiAgICBtYXJrcy5wdXNoKHtcbiAgICAgIG5hbWU6IFwiaWRlbnRcIixcbiAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiaWRlbnRfZW5kXCIsXG4gICAgICBwb3NpdGlvbjogcG9zXG4gICAgfSk7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgbGV0IG5hbWVMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgaWYgKCFuYW1lTGVuKSByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgcG9zaXRpb246IHBvc1xuICAgIH07XG4gICAgbWFya3MucHVzaCh7XG4gICAgICBuYW1lOiBcImlkZW50XCIsXG4gICAgICBwb3NpdGlvbjogcG9zXG4gICAgfSwge1xuICAgICAgbmFtZTogXCJpZGVudF9lbmRcIixcbiAgICAgIHBvc2l0aW9uOiBwb3MgKyBuYW1lTGVuXG4gICAgfSk7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgbmFtZUxlbik7XG4gICAgaWYgKHN0cltwb3NdICE9PSBcIihcIikgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9O1xuICAgIHBvcysrO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gIH0gZWxzZSB7XG4gICAgbWFya3MucHVzaCh7XG4gICAgICBuYW1lOiBcImlkZW50XCIsXG4gICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImlkZW50X2VuZFwiLFxuICAgICAgcG9zaXRpb246IHBvc1xuICAgIH0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICB9XG4gIGxldCBsYXN0UG9zID0gcG9zO1xuICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgbGFzdFBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKSBicmVhaztcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgaWYgKHN0cltwb3NdID09PSBcIilcIikgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgcG9zaXRpb246IHBvc1xuICAgIH07XG4gIH1cbiAgbWFya3MucHVzaCh7XG4gICAgbmFtZTogXCJmdW5jX2FyZ3NfZW5kXCIsXG4gICAgcG9zaXRpb246IGxhc3RQb3NcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgbWFya3MsXG4gICAgcG9zaXRpb246IHBvcyArIDFcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KHN0ciwgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFt7XG4gICAgbmFtZTogXCJvYmplY3RcIixcbiAgICBwb3NpdGlvbjogcG9zXG4gIH1dO1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgd2hpbGUgKHN0cltwb3NdICE9PSBcIn1cIikge1xuICAgIGxldCBwYWlyUG9zID0gcG9zO1xuICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gXCIuLi5cIikge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwifVwiICYmIHN0cltwb3NdICE9PSBcIixcIikge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIGV4cHI7XG4gICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IFwib2JqZWN0X3NwbGF0XCIsXG4gICAgICAgICAgcG9zaXRpb246IHBhaXJQb3NcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MpO1xuICAgICAgICBwb3MgPSBleHByLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgbmFtZTogXCJvYmplY3Rfc3BsYXRfdGhpc1wiLFxuICAgICAgICAgIHBvc2l0aW9uOiBwYWlyUG9zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpIHJldHVybiBleHByO1xuICAgICAgbGV0IG5leHRQb3MgPSBza2lwV1Moc3RyLCBleHByLnBvc2l0aW9uKTtcbiAgICAgIGlmIChleHByLm1hcmtzWzBdLm5hbWUgPT09IFwic3RyXCIgJiYgc3RyW25leHRQb3NdID09PSBcIjpcIikge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zICsgMSksIDApO1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IFwib2JqZWN0X3BhaXJcIixcbiAgICAgICAgICBwb3NpdGlvbjogcGFpclBvc1xuICAgICAgICB9KTtcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQoZXhwci5tYXJrcywgdmFsdWUubWFya3MpO1xuICAgICAgICBwb3MgPSB2YWx1ZS5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHtcbiAgICAgICAgICBuYW1lOiBcIm9iamVjdF9leHByXCIsXG4gICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICB9LCBleHByLm1hcmtzKTtcbiAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKSBicmVhaztcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgfVxuICBpZiAoc3RyW3Bvc10gIT09IFwifVwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9O1xuICB9XG4gIHBvcysrO1xuICBtYXJrcy5wdXNoKHtcbiAgICBuYW1lOiBcIm9iamVjdF9lbmRcIixcbiAgICBwb3NpdGlvbjogcG9zXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgIG1hcmtzLFxuICAgIHBvc2l0aW9uOiBwb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0ciwgcG9zKSB7XG4gIGxldCB0b2tlbiA9IHN0cltwb3NdO1xuICBwb3MgPSBwb3MgKyAxO1xuICBjb25zdCBtYXJrcyA9IFt7XG4gICAgbmFtZTogXCJzdHJcIixcbiAgICBwb3NpdGlvbjogcG9zXG4gIH1dO1xuICBzdHI6IGZvciAoOzsgcG9zKyspIHtcbiAgICBpZiAocG9zID4gc3RyLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9O1xuICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICAgIGNhc2UgdG9rZW46XG4gICAgICAgIHtcbiAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwic3RyX2VuZFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGJyZWFrIHN0cjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAge1xuICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJzdHJfcGF1c2VcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc3RyW3BvcyArIDFdID09PSBcInVcIikge1xuICAgICAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJ1bmljb2RlX2hleFwiLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBwb3MgPSBzdHIuaW5kZXhPZihcIn1cIiwgcG9zICsgMyk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidW5pY29kZV9oZXhcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJ1bmljb2RlX2hleF9lbmRcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zICsgNlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcG9zICs9IDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lOiBcInNpbmdsZV9lc2NhcGVcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJzdHJfc3RhcnRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICBtYXJrcyxcbiAgICBwb3NpdGlvbjogcG9zXG4gIH07XG59XG5mdW5jdGlvbiBza2lwV1Moc3RyLCBwb3MpIHtcbiAgcmV0dXJuIHBvcyArIHBhcnNlUmVnZXgoc3RyLCBwb3MsIFdTKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVnZXgoc3RyLCBwb3MsIHJlKSB7XG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XG4gIHJldHVybiBtID8gbVswXS5sZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gcGFyc2VSZWdleFN0cihzdHIsIHBvcywgcmUpIHtcbiAgbGV0IG0gPSByZS5leGVjKHN0ci5zbGljZShwb3MpKTtcbiAgcmV0dXJuIG0gPyBtWzBdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGpvaW4oYSwgYikge1xuICByZXR1cm4gYmFzZSA9PiBiKGEoYmFzZSkpO1xufVxuZnVuY3Rpb24gbWFwKGlubmVyKSB7XG4gIHJldHVybiBiYXNlID0+ICh7XG4gICAgdHlwZTogXCJNYXBcIixcbiAgICBiYXNlLFxuICAgIGV4cHI6IGlubmVyKHtcbiAgICAgIHR5cGU6IFwiVGhpc1wiXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBmbGF0TWFwKGlubmVyKSB7XG4gIHJldHVybiBiYXNlID0+ICh7XG4gICAgdHlwZTogXCJGbGF0TWFwXCIsXG4gICAgYmFzZSxcbiAgICBleHByOiBpbm5lcih7XG4gICAgICB0eXBlOiBcIlRoaXNcIlxuICAgIH0pXG4gIH0pO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VBcnJheShidWlsZCwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgYnVpbGRcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgbWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgIH07XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIGZsYXRNYXAocmlnaHQuYnVpbGQpKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVBsYWluKG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUVsZW1lbnQobWFwcGVyLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICBidWlsZDogbWFwcGVyXG4gICAgfTtcbiAgfVxuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiLmNvbmNhdChyaWdodC50eXBlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUHJvamVjdGlvbihtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICB9XG59XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY29uc3QgRVNDQVBFX1NFUVVFTkNFID0ge1xuICBcIidcIjogXCInXCIsXG4gICdcIic6ICdcIicsXG4gIFwiXFxcXFwiOiBcIlxcXFxcIixcbiAgXCIvXCI6IFwiL1wiLFxuICBiOiBcIlxcYlwiLFxuICBmOiBcIlxcZlwiLFxuICBuOiBcIlxcblwiLFxuICByOiBcIlxcclwiLFxuICB0OiBcIlx0XCJcbn07XG5mdW5jdGlvbiBleHBhbmRIZXgoc3RyKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn1cbmNsYXNzIEdyb3FRdWVyeUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJuYW1lXCIsIFwiR3JvcVF1ZXJ5RXJyb3JcIik7XG4gIH1cbn1cbmNvbnN0IEVYUFJfQlVJTERFUiA9IHtcbiAgZ3JvdXAocCkge1xuICAgIGNvbnN0IGlubmVyID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiR3JvdXBcIixcbiAgICAgIGJhc2U6IGlubmVyXG4gICAgfTtcbiAgfSxcbiAgZXZlcnl0aGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJFdmVyeXRoaW5nXCJcbiAgICB9O1xuICB9LFxuICB0aGlzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlRoaXNcIlxuICAgIH07XG4gIH0sXG4gIHBhcmVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXJlbnRcIixcbiAgICAgIG46IDFcbiAgICB9O1xuICB9LFxuICBkYmxwYXJlbnQocCkge1xuICAgIGNvbnN0IG5leHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXJlbnRcIixcbiAgICAgIG46IG5leHQubiArIDFcbiAgICB9O1xuICB9LFxuICB0cmF2ZXJzZShwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHRyYXZlcnNhbExpc3QgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJ0cmF2ZXJzYWxfZW5kXCIpIHtcbiAgICAgIHRyYXZlcnNhbExpc3QucHVzaChwLnByb2Nlc3MoVFJBVkVSU0VfQlVJTERFUikpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgbGV0IHRyYXZlcnNhbCA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IHRyYXZlcnNhbExpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRyYXZlcnNhbCA9IHRyYXZlcnNhbExpc3RbaV0odHJhdmVyc2FsKTtcbiAgICB9XG4gICAgaWYgKGJhc2UudHlwZSA9PT0gXCJFdmVyeXRoaW5nXCIgfHwgYmFzZS50eXBlID09PSBcIkFycmF5XCIgfHwgYmFzZS50eXBlID09PSBcIlBpcGVGdW5jQ2FsbFwiKSB7XG4gICAgICB0cmF2ZXJzYWwgPSB0cmF2ZXJzZUFycmF5KHZhbCA9PiB2YWwsIHRyYXZlcnNhbCk7XG4gICAgfVxuICAgIGlmICh0cmF2ZXJzYWwgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkJVRzogdW5leHBlY3RlZCBlbXB0eSB0cmF2ZXJzYWxcIik7XG4gICAgcmV0dXJuIHRyYXZlcnNhbC5idWlsZChiYXNlKTtcbiAgfSxcbiAgdGhpc19hdHRyKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgaWYgKG5hbWUgPT09IFwibnVsbFwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcImZhbHNlXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIixcbiAgICAgIG5hbWVcbiAgICB9O1xuICB9LFxuICBuZWcocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJOZWdcIixcbiAgICAgIGJhc2VcbiAgICB9O1xuICB9LFxuICBwb3MocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQb3NcIixcbiAgICAgIGJhc2VcbiAgICB9O1xuICB9LFxuICBhZGQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiK1wiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgc3ViKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIi1cIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG11bChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIqXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBkaXYocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiL1wiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbW9kKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIiVcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIHBvdyhwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIqKlwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgY29tcChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IG9wID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgaW5fcmFuZ2UocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCBpc0luY2x1c2l2ZSA9IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiaW5jX3JhbmdlXCI7XG4gICAgcC5zaGlmdCgpO1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkluUmFuZ2VcIixcbiAgICAgIGJhc2UsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICBpc0luY2x1c2l2ZVxuICAgIH07XG4gIH0sXG4gIHN0cihwKSB7XG4gICAgbGV0IHZhbHVlID0gXCJcIjtcbiAgICBsb29wOiB3aGlsZSAocC5oYXNNYXJrKCkpIHtcbiAgICAgIGNvbnN0IG1hcmsgPSBwLmdldE1hcmsoKTtcbiAgICAgIHN3aXRjaCAobWFyay5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJzdHJfZW5kXCI6XG4gICAgICAgICAgdmFsdWUgKz0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgY2FzZSBcInN0cl9wYXVzZVwiOlxuICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RyX3N0YXJ0XCI6XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2luZ2xlX2VzY2FwZVwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBwLnNsaWNlKDEpO1xuICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgdmFsdWUgKz0gRVNDQVBFX1NFUVVFTkNFW2NoYXJdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwidW5pY29kZV9oZXhcIjpcbiAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgdmFsdWUgKz0gZXhwYW5kSGV4KHAucHJvY2Vzc1N0cmluZ0VuZCgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIG1hcms6IFwiLmNvbmNhdChtYXJrLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgaW50ZWdlcihwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBmbG9hdChwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBzY2kocCkge1xuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0KHApIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwib2JqZWN0X2VuZFwiKSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2gocC5wcm9jZXNzKE9CSkVDVF9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9O1xuICB9LFxuICBhcnJheShwKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJhcnJheV9lbmRcIikge1xuICAgICAgbGV0IGlzU3BsYXQgPSBmYWxzZTtcbiAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcImFycmF5X3NwbGF0XCIpIHtcbiAgICAgICAgaXNTcGxhdCA9IHRydWU7XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICBlbGVtZW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJBcnJheUVsZW1lbnRcIixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGlzU3BsYXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQXJyYXlcIixcbiAgICAgIGVsZW1lbnRzXG4gICAgfTtcbiAgfSxcbiAgdHVwbGUocCkge1xuICAgIGNvbnN0IG1lbWJlcnMgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJ0dXBsZV9lbmRcIikge1xuICAgICAgbWVtYmVycy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlR1cGxlXCIsXG4gICAgICBtZW1iZXJzXG4gICAgfTtcbiAgfSxcbiAgZnVuY19jYWxsKHApIHtcbiAgICBsZXQgbmFtZXNwYWNlID0gXCJnbG9iYWxcIjtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIikge1xuICAgICAgcC5zaGlmdCgpO1xuICAgICAgbmFtZXNwYWNlID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogXCJTZWxlY3RcIixcbiAgICAgICAgYWx0ZXJuYXRpdmVzOiBbXVxuICAgICAgfTtcbiAgICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIikge1xuICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJwYWlyXCIpIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKSB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpXCIpO1xuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgIHJlc3VsdC5hbHRlcm5hdGl2ZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIlNlbGVjdEFsdGVybmF0aXZlXCIsXG4gICAgICAgICAgICBjb25kaXRpb24sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuZmFsbGJhY2sgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcC5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIikge1xuICAgICAgaWYgKGFyZ3VtZW50U2hvdWxkQmVTZWxlY3RvcihuYW1lc3BhY2UsIG5hbWUsIGFyZ3MubGVuZ3RoKSkge1xuICAgICAgICBwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUik7XG4gICAgICAgIGFyZ3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJTZWxlY3RvclwiXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJncy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIGlmIChuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgKG5hbWUgPT09IFwiYmVmb3JlXCIgfHwgbmFtZSA9PT0gXCJhZnRlclwiKSkge1xuICAgICAgaWYgKHAucGFyc2VPcHRpb25zLm1vZGUgPT09IFwiZGVsdGFcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiQ29udGV4dFwiLFxuICAgICAgICAgIGtleTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwiYm9vc3RcIiAmJiAhcC5hbGxvd0Jvb3N0KSB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0XCIpO1xuICAgIGNvbnN0IGZ1bmNzID0gbmFtZXNwYWNlc1tuYW1lc3BhY2VdO1xuICAgIGlmICghZnVuY3MpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBuYW1lc3BhY2U6IFwiLmNvbmNhdChuYW1lc3BhY2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnVuYyA9IGZ1bmNzW25hbWVdO1xuICAgIGlmICghZnVuYykge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIGZ1bmN0aW9uOiBcIi5jb25jYXQobmFtZSkpO1xuICAgIH1cbiAgICBpZiAoZnVuYy5hcml0eSAhPT0gdm9pZCAwKSB7XG4gICAgICB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmMuYXJpdHksIGFyZ3MubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKGZ1bmMubW9kZSAhPT0gdm9pZCAwICYmIGZ1bmMubW9kZSAhPT0gcC5wYXJzZU9wdGlvbnMubW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIGZ1bmN0aW9uOiBcIi5jb25jYXQobmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJGdW5jQ2FsbFwiLFxuICAgICAgZnVuYyxcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIG5hbWUsXG4gICAgICBhcmdzXG4gICAgfTtcbiAgfSxcbiAgcGlwZWNhbGwocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBwLnNoaWZ0KCk7XG4gICAgbGV0IG5hbWVzcGFjZSA9IFwiZ2xvYmFsXCI7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwibmFtZXNwYWNlXCIpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIG5hbWVzcGFjZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlICE9PSBcImdsb2JhbFwiKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgbmFtZXNwYWNlOiBcIi5jb25jYXQobmFtZXNwYWNlKSk7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgY29uc3Qgb2xkQWxsb3dCb29zdCA9IHAuYWxsb3dCb29zdDtcbiAgICBpZiAobmFtZSA9PT0gXCJzY29yZVwiKSB7XG4gICAgICBwLmFsbG93Qm9vc3QgPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCBtYXJrTmFtZSA9IHAuZ2V0TWFyaygpLm5hbWU7XG4gICAgICBpZiAobWFya05hbWUgPT09IFwiZnVuY19hcmdzX2VuZFwiKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09IFwib3JkZXJcIikge1xuICAgICAgICBpZiAobWFya05hbWUgPT09IFwiYXNjXCIpIHtcbiAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgYXJncy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiQXNjXCIsXG4gICAgICAgICAgICBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1hcmtOYW1lID09PSBcImRlc2NcIikge1xuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBhcmdzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJEZXNjXCIsXG4gICAgICAgICAgICBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcC5hbGxvd0Jvb3N0ID0gb2xkQWxsb3dCb29zdDtcbiAgICBjb25zdCBmdW5jID0gcGlwZUZ1bmN0aW9uc1tuYW1lXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBwaXBlIGZ1bmN0aW9uOiBcIi5jb25jYXQobmFtZSkpO1xuICAgIH1cbiAgICBpZiAoZnVuYy5hcml0eSkge1xuICAgICAgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBpcGVGdW5jQ2FsbFwiLFxuICAgICAgZnVuYyxcbiAgICAgIGJhc2UsXG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH07XG4gIH0sXG4gIHBhaXIocCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgPT5cIik7XG4gIH0sXG4gIGFuZChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQW5kXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBvcihwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3JcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG5vdChwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk5vdFwiLFxuICAgICAgYmFzZVxuICAgIH07XG4gIH0sXG4gIGFzYyhwKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBhc2NcIik7XG4gIH0sXG4gIGRlc2MocCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgZGVzY1wiKTtcbiAgfSxcbiAgcGFyYW0ocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBpZiAocC5wYXJzZU9wdGlvbnMucGFyYW1zICYmIHAucGFyc2VPcHRpb25zLnBhcmFtcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgICB2YWx1ZTogcC5wYXJzZU9wdGlvbnMucGFyYW1zW25hbWVdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXJhbWV0ZXJcIixcbiAgICAgIG5hbWVcbiAgICB9O1xuICB9XG59O1xuY29uc3QgT0JKRUNUX0JVSUxERVIgPSB7XG4gIG9iamVjdF9leHByKHApIHtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJwYWlyXCIpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgY29uc3QgdmFsdWUyID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIk9iamVjdENvbmRpdGlvbmFsU3BsYXRcIixcbiAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIsXG4gICAgICBuYW1lOiBleHRyYWN0UHJvcGVydHlLZXkodmFsdWUpLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBvYmplY3RfcGFpcihwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGlmIChuYW1lLnR5cGUgIT09IFwiVmFsdWVcIikgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIsXG4gICAgICBuYW1lOiBuYW1lLnZhbHVlLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBvYmplY3Rfc3BsYXQocCkge1xuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3NwbGF0X3RoaXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IFwiVGhpc1wiXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IFRSQVZFUlNFX0JVSUxERVIgPSB7XG4gIHNxdWFyZV9icmFja2V0KHApIHtcbiAgICBjb25zdCBleHByID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgdmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGV4cHIpO1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gcmlnaHQgPT4gdHJhdmVyc2VFbGVtZW50KGJhc2UgPT4gKHtcbiAgICAgICAgdHlwZTogXCJBY2Nlc3NFbGVtZW50XCIsXG4gICAgICAgIGJhc2UsXG4gICAgICAgIGluZGV4OiB2YWx1ZS5kYXRhXG4gICAgICB9KSwgcmlnaHQpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHJpZ2h0ID0+IHRyYXZlcnNlUGxhaW4oYmFzZSA9PiAoe1xuICAgICAgICB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLFxuICAgICAgICBiYXNlLFxuICAgICAgICBuYW1lOiB2YWx1ZS5kYXRhXG4gICAgICB9KSwgcmlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmlnaHQgPT4gdHJhdmVyc2VBcnJheShiYXNlID0+ICh7XG4gICAgICB0eXBlOiBcIkZpbHRlclwiLFxuICAgICAgYmFzZSxcbiAgICAgIGV4cHJcbiAgICB9KSwgcmlnaHQpO1xuICB9LFxuICBzbGljZShwKSB7XG4gICAgY29uc3QgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSBcImluY19yYW5nZVwiO1xuICAgIHAuc2hpZnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGxlZnQpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKHJpZ2h0KTtcbiAgICBpZiAoIWxlZnRWYWx1ZSB8fCAhcmlnaHRWYWx1ZSB8fCBsZWZ0VmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInNsaWNpbmcgbXVzdCB1c2UgY29uc3RhbnQgbnVtYmVyc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJocyA9PiB0cmF2ZXJzZUFycmF5KGJhc2UgPT4gKHtcbiAgICAgIHR5cGU6IFwiU2xpY2VcIixcbiAgICAgIGJhc2UsXG4gICAgICBsZWZ0OiBsZWZ0VmFsdWUuZGF0YSxcbiAgICAgIHJpZ2h0OiByaWdodFZhbHVlLmRhdGEsXG4gICAgICBpc0luY2x1c2l2ZVxuICAgIH0pLCByaHMpO1xuICB9LFxuICBwcm9qZWN0aW9uKHApIHtcbiAgICBjb25zdCBvYmogPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4gcmlnaHQgPT4gdHJhdmVyc2VQcm9qZWN0aW9uKGJhc2UgPT4gKHtcbiAgICAgIHR5cGU6IFwiUHJvamVjdGlvblwiLFxuICAgICAgYmFzZSxcbiAgICAgIGV4cHI6IG9ialxuICAgIH0pLCByaWdodCk7XG4gIH0sXG4gIGF0dHJfYWNjZXNzKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgcmV0dXJuIHJpZ2h0ID0+IHRyYXZlcnNlUGxhaW4oYmFzZSA9PiAoe1xuICAgICAgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIixcbiAgICAgIGJhc2UsXG4gICAgICBuYW1lXG4gICAgfSksIHJpZ2h0KTtcbiAgfSxcbiAgZGVyZWYocCkge1xuICAgIGxldCBhdHRyID0gbnVsbDtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJkZXJlZl9hdHRyXCIpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIGF0dHIgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcCA9IGJhc2UgPT4gYXR0ciA/IHtcbiAgICAgIHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsXG4gICAgICBiYXNlLFxuICAgICAgbmFtZTogYXR0clxuICAgIH0gOiBiYXNlO1xuICAgIHJldHVybiByaWdodCA9PiB0cmF2ZXJzZVBsYWluKGJhc2UgPT4gd3JhcCh7XG4gICAgICB0eXBlOiBcIkRlcmVmXCIsXG4gICAgICBiYXNlXG4gICAgfSksIHJpZ2h0KTtcbiAgfSxcbiAgYXJyYXlfcG9zdGZpeChwKSB7XG4gICAgcmV0dXJuIHJpZ2h0ID0+IHRyYXZlcnNlQXJyYXkoYmFzZSA9PiAoe1xuICAgICAgdHlwZTogXCJBcnJheUNvZXJjZVwiLFxuICAgICAgYmFzZVxuICAgIH0pLCByaWdodCk7XG4gIH1cbn07XG5jb25zdCBTRUxFQ1RPUl9CVUlMREVSID0ge1xuICBncm91cChwKSB7XG4gICAgcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpO1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBldmVyeXRoaW5nKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICB0aGlzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwYXJlbnQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRibHBhcmVudChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHRyYXZlcnNlKHApIHtcbiAgICBwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUik7XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHJhdmVyc2FsX2VuZFwiKSB7XG4gICAgICBwLnByb2Nlc3MoVFJBVkVSU0VfQlVJTERFUik7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgdGhpc19hdHRyKHApIHtcbiAgICBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgbmVnKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcG9zKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYWRkKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgc3ViKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgbXVsKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZGl2KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgbW9kKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcG93KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgY29tcChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGluX3JhbmdlKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgc3RyKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgaW50ZWdlcihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGZsb2F0KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgc2NpKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgb2JqZWN0KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYXJyYXkocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICB0dXBsZShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGZ1bmNfY2FsbChwLCBtYXJrKSB7XG4gICAgY29uc3QgZnVuYyA9IEVYUFJfQlVJTERFUi5mdW5jX2NhbGwocCwgbWFyayk7XG4gICAgaWYgKGZ1bmMubmFtZSA9PT0gXCJhbnl3aGVyZVwiICYmIGZ1bmMuYXJncy5sZW5ndGggPT09IDEpIHJldHVybiBudWxsO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwaXBlY2FsbChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBhaXIocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhbmQocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBvcihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG5vdChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFzYyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRlc2MocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwYXJhbShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH1cbn07XG5mdW5jdGlvbiBleHRyYWN0UHJvcGVydHlLZXkobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSBcIkFjY2Vzc0F0dHJpYnV0ZVwiICYmICFub2RlLmJhc2UpIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IFwiRGVyZWZcIiB8fCBub2RlLnR5cGUgPT09IFwiTWFwXCIgfHwgbm9kZS50eXBlID09PSBcIlByb2plY3Rpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiU2xpY2VcIiB8fCBub2RlLnR5cGUgPT09IFwiRmlsdGVyXCIgfHwgbm9kZS50eXBlID09PSBcIkFjY2Vzc0VsZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiQXJyYXlDb2VyY2VcIikge1xuICAgIHJldHVybiBleHRyYWN0UHJvcGVydHlLZXkobm9kZS5iYXNlKTtcbiAgfVxuICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJDYW5ub3QgZGV0ZXJtaW5lIHByb3BlcnR5IGtleSBmb3IgdHlwZTogXCIuY29uY2F0KG5vZGUudHlwZSkpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBcml0eShuYW1lLCBhcml0eSwgY291bnQpIHtcbiAgaWYgKHR5cGVvZiBhcml0eSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChjb3VudCAhPT0gYXJpdHkpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIkluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIFwiLmNvbmNhdChuYW1lLCBcIigpLiBFeHBlY3RlZCBcIikuY29uY2F0KGFyaXR5LCBcIiwgZ290IFwiKS5jb25jYXQoY291bnQsIFwiLlwiKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyaXR5KSB7XG4gICAgaWYgKCFhcml0eShjb3VudCkpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIkluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIFwiLmNvbmNhdChuYW1lLCBcIigpLlwiKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBmdW5jdGlvbk5hbWUsIGFyZ0NvdW50KSB7XG4gIGNvbnN0IGZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycyA9IFtcImNoYW5nZWRBbnlcIiwgXCJjaGFuZ2VkT25seVwiXTtcbiAgcmV0dXJuIG5hbWVzcGFjZSA9PSBcImRpZmZcIiAmJiBhcmdDb3VudCA9PSAyICYmIGZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycy5pbmNsdWRlcyhmdW5jdGlvbk5hbWUpO1xufVxuY2xhc3MgR3JvcVN5bnRheEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihwb3NpdGlvbikge1xuICAgIHN1cGVyKFwiU3ludGF4IGVycm9yIGluIEdST1EgcXVlcnkgYXQgcG9zaXRpb24gXCIuY29uY2F0KHBvc2l0aW9uKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBvc2l0aW9uXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJuYW1lXCIsIFwiR3JvcVN5bnRheEVycm9yXCIpO1xuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBjb25zdCByZXN1bHQgPSBwYXJzZSQxKGlucHV0KTtcbiAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICB0aHJvdyBuZXcgR3JvcVN5bnRheEVycm9yKHJlc3VsdC5wb3NpdGlvbik7XG4gIH1cbiAgY29uc3QgcHJvY2Vzc29yID0gbmV3IE1hcmtQcm9jZXNzb3IoaW5wdXQsIHJlc3VsdC5tYXJrcywgb3B0aW9ucyk7XG4gIHJldHVybiBwcm9jZXNzb3IucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xufVxuZXhwb3J0cy5EYXRlVGltZSA9IERhdGVUaW1lO1xuZXhwb3J0cy5ldmFsdWF0ZSA9IGV2YWx1YXRlUXVlcnk7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD0xLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/groq-js/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/groq-js/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar _1 = __webpack_require__(/*! ./1.js */ \"(ssr)/./node_modules/groq-js/dist/1.js\");\nexports.DateTime = _1.DateTime;\nexports.evaluate = _1.evaluate;\nexports.parse = _1.parse;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLFNBQVMsbUJBQU8sQ0FBQyxzREFBUTtBQUN6QixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc2FuaXR5LWFwcC8uL25vZGVfbW9kdWxlcy9ncm9xLWpzL2Rpc3QvaW5kZXguanM/YjUzYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIF8xID0gcmVxdWlyZSgnLi8xLmpzJyk7XG5leHBvcnRzLkRhdGVUaW1lID0gXzEuRGF0ZVRpbWU7XG5leHBvcnRzLmV2YWx1YXRlID0gXzEuZXZhbHVhdGU7XG5leHBvcnRzLnBhcnNlID0gXzEucGFyc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/index.js\n");

/***/ })

};
;